"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"premature_systems","metadata":{"permalink":"/blog/premature_systems","source":"@site/blog/2024-09-23_Premature_systems.md","title":"Premature event listeners","description":"Premature event listeners in UMG, and why we should try to avoid them in the future.","date":"2024-09-23T00:00:00.000Z","formattedDate":"September 23, 2024","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":1.77,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"premature_systems","title":"Premature event listeners","tags":["design","umg"]},"nextItem":{"title":"UMG Style Guide","permalink":"/blog/umg_style_guide"}},"content":"Premature event listeners in UMG, and why we should try to avoid them in the future.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nIn UMG, qbuses and evbuses have been a complete godsend.  \\r\\nThey have allowed us to create behaviour, and [delay the semantics](./2024-04-22_DELS.md) to future systems, so future systems can have more of a say.\\r\\n\\r\\nSimplified example of this-  \\r\\nRendering system:  \\r\\n```lua\\r\\n-- rendering mod:\\r\\numg.on(\\"@draw\\", function()\\r\\n    for _, ent in sortedEntities(cameraDimension) do\\r\\n        umg.call(\\"rendering:drawEntity\\", ent, x, y)\\r\\n    end\\r\\nend)\\r\\n```\\r\\n\\r\\nAnd what\'s super-cool about this, is that we can extend the drawing\\r\\nof entities by simply tagging onto the emitted event:\\r\\n```lua\\r\\n-- lootplot mod:\\r\\numg.on(\\"rendering:drawEntity\\", function(ent, x, y)\\r\\n    if ent.slot and isHovered(ent) then\\r\\n        drawIndicator(ent, x, y)\\r\\n    end\\r\\nend)\\r\\n```\\r\\n---\\r\\n\\r\\n# But wait! This setup is dumb!\\r\\n\\r\\nWhy?  \\r\\nWell, 2 reasons:\\r\\n\\r\\n### 1: The project (as a whole) becomes slightly harder to understand\\r\\nWith systems like this, it becomes harder to get a grand-overview of the project.  \\r\\n(Such is the price of highly-aggressive decoupling.)\\r\\n\\r\\n### 2: Future systems cannot control as much.\\r\\nLets imagine that we had a \\"lobby/menu\\" screen; where the player isn\'t actually in the game; but rather, exists within a menu.  \\r\\nWith this, we ideally dont WANT to render the world-entities. But we are forced to, because the system is responding to the `@draw` event prematurely.\\r\\n\\r\\n# A simple alternative:\\r\\nJust expose the function:\\r\\n```lua\\r\\nfunction rendering.drawEntities()\\r\\n    for _, ent in sortedEntities(cameraDimension) do\\r\\n        umg.call(\\"rendering:drawEntity\\", ent, x, y)\\r\\n    end\\r\\nend\\r\\n```\\r\\nAnd then just call it directly whenever, and *wherever*.  \\r\\nEG:\\r\\n```lua\\r\\nfunction GameState:draw()\\r\\n    rendering.drawEntities()\\r\\nend\\r\\n```\\r\\nAnd this is amazing too, because we can also apply shaders, do fancy transformations, and do whatever pre/post-processing that we want; since *we control the call-site:*  \\r\\n```lua\\r\\nfunction GameState:draw()\\r\\n    applyShader()\\r\\n    doPreProcessing()\\r\\n    rendering.drawEntities()\\r\\n    doPostProcessing()\\r\\nend\\r\\n```\\r\\nAmazing.\\r\\n\\r\\nCurrently in UMG, most systems are not implemented like this.\\r\\n\\r\\nBut they *definitely should be*, and it was a mistake not to have them be like this.  \\r\\nAlthough a big global event tree is minimalistic, elegant, and beautiful at first-sight; yielding extra control to the future-mods is SO VERY IMPORTANT in UMG.\\r\\n\\r\\n## FOR ALL FUTURE SYSTEMS, TRY TO AVOID DEFINING EVENT-LISTENERS PREMATURELY."},{"id":"umg_style_guide","metadata":{"permalink":"/blog/umg_style_guide","source":"@site/blog/2024-08-26_UMG_STYLE_GUIDE.md","title":"UMG Style Guide","description":"UMG Style guide.","date":"2024-08-26T00:00:00.000Z","formattedDate":"August 26, 2024","tags":[{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":2.94,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"umg_style_guide","title":"UMG Style Guide","tags":["umg"]},"prevItem":{"title":"Premature event listeners","permalink":"/blog/premature_systems"},"nextItem":{"title":"The Zen of UMG","permalink":"/blog/zen_of_umg"}},"content":"UMG Style guide.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n# THE GOLDEN RULE:\\r\\nTry write code that is *as readable as possible*.\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n# Comments\\r\\n- Keep comments TERSE, not VERBOSE.\\r\\n- Conciseness > Proper grammar\\r\\n- Dont leave comments for simple code. \\r\\n- Use `TODO`s / `FIXME`s when appropriate\\r\\n\\r\\nEXAMPLE FOR COMMENTS:\\r\\n```lua\\r\\n\\r\\nfunction doStuff(entArray)\\r\\n    ...\\r\\n    --[[\\r\\n    The reason we don\'t simply loop over the entire array of entities,\\r\\n    and delete each one is because they are used by the item-system \\r\\n    for when the item-drops are polled after receiving `clean` event.\\r\\n    ]]\\r\\n    scheduling.delay(0, function()\\r\\n        for _, ent in ipairs()\\r\\n            ent:delete()\\r\\n        end\\r\\n    end)\\r\\nend\\r\\n\\r\\n-- ^^^^ BAD BAD BAD! Explanation is too verbose!\\r\\n\\r\\n\\r\\nlocal function doStuff(entArray)\\r\\n    ...\\r\\n    -- Cannot delete immediately, \\r\\n    -- item_system.lua needs them for `clean` event.\\r\\n    scheduling.delay(0, function()\\r\\n        for _, ent in ipairs()\\r\\n            ent:delete()\\r\\n        end\\r\\n    end)\\r\\nend\\r\\n\\r\\n--- ^^^^ MUCH BETTER.\\r\\n```\\r\\nIn general, be very aggressive when shortening comments.  \\r\\nEG:  \\r\\n- BAD: `\\"Looping over the itemPool array is inefficient\\"`\\r\\n- Much better: `\\"looping over itemPool is slow\\"`\\r\\n\\r\\n---\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n# Readable Variables:  \\r\\nTo compensate for less comments, we want code to read like english would.   \\r\\nIdeally you should be able to read code similar to how you would read english.\\r\\n\\r\\n(Try to prefix boolean variables with `can` or `is` when appropriate.)   \\r\\nEXAMPLE:\\r\\n```lua\\r\\n\\r\\nfunction doStuff2(ent)\\r\\n    if (not umg.ask(\\"items:isInventoryLocked\\", ent)) then\\r\\n        -- ^^^ BAD! unreadable!!\\r\\n        ...\\r\\n    end\\r\\nend\\r\\n\\r\\n\\r\\nfunction doStuff2(ent)\\r\\n    local canOpen = (not umg.ask(\\"items:isInventoryLocked\\", ent))\\r\\n    if canOpen then\\r\\n        -- ^^^ MUCH BETTER :)))\\r\\n        -- (reads well: \\"if canOpen then\\")\\r\\n        ...\\r\\n    end\\r\\nend\\r\\n\\r\\n\\r\\n-- OR, EVEN BETTER:\\r\\nfunction doStuff3(ent)\\r\\n    if canOpen(ent) then\\r\\n        -- ^^^ WOW, SO READABLE :D much wow\\r\\n        ...\\r\\n    end\\r\\nend\\r\\n```\\r\\n\\r\\nIn general, localize when appropriate:\\r\\n```lua\\r\\n-- BAD!!!!\\r\\nfunction foo()\\r\\n    print(my_table.position.x)\\r\\n    print(my_table.position.y)\\r\\n    print(my_table.position.z)\\r\\nend\\r\\n\\r\\n-- better:\\r\\nfunction foo()\\r\\n    local pos = my_table.position\\r\\n    print(pos.x)\\r\\n    print(pos.y)\\r\\n    print(pos.z)\\r\\nend\\r\\n```\\r\\n\\r\\n----\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n\\r\\n\\r\\n# Indentation\\r\\nUse 4 spaces please.\\r\\n\\r\\n----\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n\\r\\n# Line spacing\\r\\nIn UMG, we use line-spacing to group together related bits of code, to make it more readable.  \\r\\n\\r\\nFor functions/code that do similar stuff, group them tightly together.  \\r\\nElse, split them apart using newlines.\\r\\n\\r\\nEXAMPLE:\\r\\n```lua\\r\\n\\r\\nlocal util = {}\\r\\n\\r\\n\\r\\n\\r\\nfunction util.tryCall(f, ...)\\r\\n    ...\\r\\nend\\r\\n\\r\\n\\r\\n-- notice the newlines here\\r\\n\\r\\n\\r\\nfunction util.log(msg)\\r\\n    ...\\r\\nend\\r\\n\\r\\n\\r\\n-- and here\\r\\n\\r\\n\\r\\nlocal function newCompresser(str)\\r\\n    return ...\\r\\nend\\r\\n-- but only one newline here!\\r\\nfunction util.compressString(str)\\r\\n    local b = newCompresser(str)\\r\\n    ...\\r\\nend\\r\\n-- and only one here!\\r\\nfunction util.decompressString(str)\\r\\n    ...\\r\\nend\\r\\n```\\r\\n\\r\\nthis helps us reason about the code better,\\r\\nbecause it is broken up implicitly into regions.\\r\\n\\r\\n(In general, code is never really something that you read top-to-bottom like a book; but rather, more similar to a bunch of nodes connected in a big graph.)\\r\\n\\r\\nIdeally, try to use 3 or 4 newlines between unrelated functions, and 1 newline between related functions.\\r\\n\\r\\n*WITHIN* a function, there should be a maximum of ONE newline between statements.  \\r\\n(It should follow the same rule as above; create space if the statements are unrelated)\\r\\n\\r\\n----\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n# Table arguments:\\r\\nIf you have many arguments, consider combining them into a table:\\r\\n```lua\\r\\n\\r\\n-- BAD!!! it\'s hard to tell what\'s happening\\r\\ndispatchCommand(cmd, b.foo, r, r2)\\r\\n\\r\\n-- GOOD. This is readable:\\r\\ndispatchCommand({\\r\\n    type = cmd,\\r\\n    argumentTable = b.foo,\\r\\n    viewArea = r,\\r\\n    spawnArea = r2\\r\\n})\\r\\n\\r\\n-- THIS IS GOOD TOO:\\r\\ndispatchCommand(cmd, {\\r\\n    argumentTable = b.foo,\\r\\n    viewArea = r,\\r\\n    spawnArea = r2\\r\\n})\\r\\n```\\r\\nIMPORTANT DISCLAIMER:  \\r\\nUsing a table is very inefficient compared to arguments, since it incurs an allocation.  \\r\\nOnly use a table if it won\'t impact performance much."},{"id":"zen_of_umg","metadata":{"permalink":"/blog/zen_of_umg","source":"@site/blog/2024-08-26_ZEN_OF_UMG.md","title":"The Zen of UMG","description":"Some quick guidelines that summarize the current UMG design philosophy.","date":"2024-08-26T00:00:00.000Z","formattedDate":"August 26, 2024","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":1.955,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"zen_of_umg","title":"The Zen of UMG","tags":["design","umg"]},"prevItem":{"title":"UMG Style Guide","permalink":"/blog/umg_style_guide"},"nextItem":{"title":"Entity propagation","permalink":"/blog/ent_propagation"}},"content":"Some quick guidelines that summarize the current UMG design philosophy.<br/>\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n<br/>\\r\\n\\r\\n## NOTE: all of this is subject to nuance!\\r\\nIf you disagree with something, or have a counterexample, let me know. I would love to discuss it.  \\r\\nThis file basically seeks to clarify UMG\'s current ideology.\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n# UMG High-Level Philosophy:\\r\\n\\r\\n- Follow the 80/20 rule\\r\\n\\r\\n- Less code > more code\\r\\n\\r\\n- Readibility and Elegance > efficiency (Unless it\'s really bad)\\r\\n\\r\\n- Simple and assumptionless > Complex and flexible\\r\\n\\r\\n- Bloat is the greatest evil\\r\\n\\r\\n- State is an evil neccessity:\\r\\n    - Try to keep the program state inside of components. \\r\\n    - If that\'s not possible, immutable and short-lived state is 2nd-best.\\r\\n    - State should ideally have a SSOT\\r\\n\\r\\n- Regular data and functions > Objects and classes\\r\\n\\r\\n\\r\\n---\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n\\r\\n# Systems and Emergence:\\r\\n- DO embrace chaotic, interacting systems\\r\\n\\r\\n- DONT fight existing systems to achieve something. Instead:\\r\\n    - Find another way to achieve a similar result\\r\\n    - ALTERNATIVELY; go back, and ask what the user is gaining from this feature\\r\\n\\r\\n- If something is unnatural to implement, try avoid implementing it\\r\\n\\r\\n\\r\\n\\r\\n---\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n# Mod Cohesion:\\r\\n- The purpose of base-mods is to provide cohesion/connections within the ecosystem; \\r\\n    - NOT to reuse code!\\r\\n\\r\\n- If mod-A and mod-B know nothing about each another, they should be able to exist cohesively; \\r\\n    - (UNLESS they are both playable-mods.)\\r\\n\\r\\n### Hackiness:\\r\\nIts OK for playable/addon mods to be hacky/poorly designed. <br/>\\r\\nBut its NOT OKAY for base mods to be hacky/poorly designed. \\r\\n\\r\\n\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n---\\r\\n\\r\\n# Component design:\\r\\n\\r\\n## Unifying components:\\r\\n\\r\\nComponents should never have co-dependencies.  \\r\\nExample:\\r\\n```lua\\r\\nent.uiElement = Element()\\r\\nent.uiRegion = {x,y,w,h}\\r\\n--[[\\r\\nWhen an entity has these two components, \\r\\nthey are rendered as a UI element on screen.\\r\\n]]\\r\\n```\\r\\nBut... this is dumb.  \\r\\nWhy not just have a singular component?\\r\\n```lua\\r\\nent.ui = {\\r\\n    element = Element(),\\r\\n    region = {x,y,w,h}\\r\\n} \\r\\n```\\r\\nThis is so much better, because:\\r\\n- It tells the modder that they need BOTH `region` and `element`\\r\\n- It is less bloated\\r\\n\\r\\n## Splitting up components:\\r\\nIdeally, components should have ONE well-defined purpose.\\r\\n\\r\\nIf we think a component is doing too much, \\r\\nwe might want to decouple/split it up.\\r\\n\\r\\nFor example:\\r\\n```lua\\r\\nent.playerControl = {\\r\\n    clientId = \\"30943434343043\\",\\r\\n    type = \\r\\n}\\r\\n```\\r\\n\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n<br/>"},{"id":"ent_propagation","metadata":{"permalink":"/blog/ent_propagation","source":"@site/blog/2024-06-17_propagation.md","title":"Entity propagation","description":"This post explains entity propagation behavior in umg.","date":"2024-06-17T00:00:00.000Z","formattedDate":"June 17, 2024","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":1.235,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"ent_propagation","title":"Entity propagation","tags":["design","umg"]},"prevItem":{"title":"The Zen of UMG","permalink":"/blog/zen_of_umg"},"nextItem":{"title":"UMG Piping idiom","permalink":"/blog/piping_idiom"}},"content":"This post explains entity propagation behavior in umg.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nin UMG, deletion and cloning are propagated to other entities through components.\\r\\n\\r\\nFor example:\\r\\n```lua\\r\\nent.foo = otherEnt\\r\\n-- `ent` references `otherEnt` through component foo\\r\\n\\r\\nent:clone()\\r\\n-- otherEnt is cloned too...\\r\\n\\r\\nent:delete()\\r\\n-- otherEnt is deleted too!\\r\\n```\\r\\n\\r\\nThis concept is known as \\"propagation\\".  \\r\\nBut... why are the clone and delete operations propagated?  \\r\\n\\r\\n---\\r\\n\\r\\nConsider the following scenario:\\r\\n```lua\\r\\n-- Save and delete the ent:\\r\\nlocal data = serialize(ent)\\r\\nent:delete()\\r\\n\\r\\n-- Now load the saved ent:\\r\\nlocal ent = load(data)\\r\\n```\\r\\nThis operation could happen when we are saving a world.\\r\\n\\r\\nThe big question is: what should happen to `otherEnt`?  \\r\\nIt obviously needs to be saved alongside `ent`... Or else `ent` will lose component data.   \\r\\n\\r\\nWhat about deletion though?  \\r\\nThe simple solution is to keep `otherEnt` alive.  \\r\\nLet\'s consider this.\\r\\n\\r\\nWhen `ent` is saved, a copy of `otherEnt` is serialized and saved to `data`. This is because it is referenced inside the `foo` component.  \\r\\n\\r\\nTherefore when the data is loaded, a copy of `otherEnt` is also loaded.\\r\\n\\r\\nAha! And that\'s the big problem.   \\r\\nIf we didn\'t delete `otherEnt`, then we would have two copies of it in the ECS.   \\r\\nIn order to have entities within components, we need propagation.\\r\\n\\r\\n---\\r\\n\\r\\n## Nested propagation\\r\\n\\r\\nPropagation is applied through entities, as well as through data structures.\\r\\nFor example:\\r\\n```lua\\r\\nent.abc = {\\r\\n    hi = {ent_1, ent_2}\\r\\n    -- These are propagated.\\r\\n    -- (So is anything that these entities reference)\\r\\n}\\r\\n```"},{"id":"piping_idiom","metadata":{"permalink":"/blog/piping_idiom","source":"@site/blog/2024-04-23_piping_idiom.md","title":"UMG Piping idiom","description":"This is a bit too big for the UMG-idioms file, so imma put it here.","date":"2024-04-23T00:00:00.000Z","formattedDate":"April 23, 2024","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":1.96,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"piping_idiom","title":"UMG Piping idiom","tags":["design","umg"]},"prevItem":{"title":"Entity propagation","permalink":"/blog/ent_propagation"},"nextItem":{"title":"What is Delayed Structuring? (DELS)","permalink":"/blog/DELS"}},"content":"This is a bit too big for the UMG-idioms file, so imma put it here.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n# UMG Piping idiom:\\r\\n\\r\\n\\"Piping\\" in UMG is when we construct an object/entity, and shove it through an [evbus](../umg_terminology), with the expectation that the event-listeners will mutate/setup the object.\\r\\n\\r\\nIt provides [DELS](../DELS) when creating new objects.\\r\\n\\r\\n## Example in Chat mod:\\r\\n\\r\\nUsing the Chat-mod, we may want to have different-looking messages.  \\r\\n\\r\\nFor example, the DOOM mod may want all messages to be red, to stick with the theme.  \\r\\nThe CleanUI mod may want nice borders around messages.  \\r\\nAnd the AdminTools mod may want to make all host-messages yellow.\\r\\n\\r\\nWe can achieve this by creating a `MessageObject`, shoving it through a `pipe`, and having mods setup the object directly.\\r\\n\\r\\n\\r\\n```lua\\r\\n--[[\\r\\n    Base chat mod:\\r\\n]]\\r\\nlocal msgObject = MessageObject(msgString)\\r\\numg.call(\\"chat:pipeMessageObject\\", msgObject, clientId)\\r\\n```\\r\\n\\r\\n\\r\\n```lua\\r\\n-- DOOM mod:\\r\\nlocal ORDER = -10 -- lower priority, since it applies to ALL messages\\r\\numg.on(\\"chat:pipeMessageObject\\", function(msgObj)\\r\\n    msgObj:setColor(RED)\\r\\nend)\\r\\n\\r\\n\\r\\n-- CleanUI mod:\\r\\numg.on(\\"chat:pipeMessageObject\\", function(msgObj)\\r\\n    local oldRen = msgObj.onRender\\r\\n    -- wrapping methods:\\r\\n    function msgObj:onRender(x,y,w,h)\\r\\n        oldRen(self.text, x,y,w,h)\\r\\n\\r\\n        -- custom rendering here:\\r\\n        drawBorder(self.text, x,y,w,h) \\r\\n    end\\r\\nend)\\r\\n\\r\\n-- AdminTools mod:\\r\\numg.on(\\"chat:pipeMessageObject\\", function(msgObj, clientId)\\r\\n    if isHost(clientId)\\r\\n        msgObj:setColor(YELLOW)\\r\\n    end\\r\\nend)\\r\\n```\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n\\r\\n# Examples of piping in UMG:\\r\\nEntities and Entity-Types are both piped in UMG!\\r\\n\\r\\nProbably the best example of piping in UMG is Entity-Types:\\r\\n```lua\\r\\numg.on(\\"@defineEntityType\\", function(entityType)\\r\\n    if entityType.item then\\r\\n        -- adds to item pool\\r\\n        itemGen:add(entityType)\\r\\n    elseif entityType.enemy then\\r\\n        enemyGen:add(entityType)\\r\\n    end\\r\\nend)\\r\\n\\r\\n\\r\\nlocal function generateItem()\\r\\n    -- generates a random item!\\r\\n    local etype = itemGen:getRandom()\\r\\n    return etype()\\r\\nend\\r\\n\\r\\n```\\r\\nIn this example, we are checking for the `.item` or `.enemy` [shcomp](../umg_terminology)s.  \\r\\nIf the etype has either, then it will be added to the array;\\r\\nand will be a selection candidate when we do procedural-generation.\\r\\n\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n# When is piping GOOD?\\r\\nPiping is especially good with temporary-objects.\\r\\n\\r\\nWith temp-objects, we can be more aggressive in what we change, because the object will be disposed of anyway.  \\r\\n(Ie. If we change some state that will drastically affect the future of the object, it won\'t matter much, since it\'s only a temporary object anyway.)\\r\\n\\r\\n\\r\\n<br/>\\r\\n\\r\\n# When is piping BAD?\\r\\nPiping should ONLY be used when the object has JUST been created.\\r\\n\\r\\nIf the object is old, then other (unrelated) systems may have already changed/mutated the object.  \\r\\nWe want to ensure that we aren\'t undoing/overwriting their work."},{"id":"DELS","metadata":{"permalink":"/blog/DELS","source":"@site/blog/2024-04-22_DELS.md","title":"What is Delayed Structuring? (DELS)","description":"What is DELS?","date":"2024-04-22T00:00:00.000Z","formattedDate":"April 22, 2024","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":6.175,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"DELS","title":"What is Delayed Structuring? (DELS)","tags":["design","umg"]},"prevItem":{"title":"UMG Piping idiom","permalink":"/blog/piping_idiom"},"nextItem":{"title":"Terminology for UMG","permalink":"/blog/umg_terminology"}},"content":"What is DELS?\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nThis article is heavily related (and kinda overlapping) with [these](./2023-05-10_question_buses.md) [two](./2023-06-2_umg_tech_details.md) articles.\\r\\n\\r\\n\\"Delayed Structuring\\" or \\"DELS\\" in UMG is when we attempt to \\"delay\\" the behaviour or semantics of a system, such that future mods can change it.\\r\\n\\r\\nFor example, overriding abstract methods in OOP languages is an example of DELS.  \\r\\nWith abstract-methods, we are basically saying:  \\r\\n\\"We don\'t know how this method could work!  \\r\\nTherefore we will allow it to be overridden.\\"\\r\\n\\r\\n--- \\r\\n\\r\\nBut, overriding functions in UMG is quite... \\"meh\\".  \\r\\nBecause only one mod can override the functions!\\r\\n\\r\\nRegardless, I think its best to give an example:\\r\\n\\r\\n# The problem:\\r\\nThe rendering-mod is in charge of rendering entities;  \\r\\nSo it needs to know what entities are hidden.\\r\\n```lua\\r\\n-- Rendering mod:\\r\\n--------\\r\\nlocal function isHidden(ent)\\r\\n    ...\\r\\nend\\r\\n```\\r\\n\\r\\nLets assume we have a mod-setup like so:\\r\\n```mermaid\\r\\nflowchart LR\\r\\n    Rendering[Rendering mod]\\r\\n    Potions[Potions mod]\\r\\n    Ghosts[Ghosts mod]\\r\\n    Potions --\x3e Rendering\\r\\n    Ghosts --\x3e Rendering\\r\\n```\\r\\n\\r\\n\\r\\nIn the `Potions` mod, we want an invisibility potion.  \\r\\nAnd in the `Ghosts` mod, we want ghosts to be invisible, (unless the player has a ghost-busters item.)\\r\\n\\r\\n(`Potions` and `Ghosts` know about `Rendering`, but `Rendering` doesn\'t know about either.)\\r\\n\\r\\nThis... is a problem for us.  \\r\\nBecause the rendering mod knows NOTHING about ghosts...  \\r\\nAnd rendering knows NOTHING about potions either.   \\r\\n\\r\\nAnd yet.. the `isHidden` check is INSIDE of the `rendering` mod!!!\\r\\n\\r\\nHmm.. we need to somehow *delay* the `isHidden` check to future mods.\\r\\n\\r\\n## FEAR NOT: Behold the mighty [question bus:](./2023-05-10_question_buses.md)\\r\\n```lua\\r\\n-- Rendering mod:\\r\\nlocal function isHidden(ent)\\r\\n    return umg.ask(\\"rendering:isHidden\\", ent)\\r\\nend\\r\\n```\\r\\n\\r\\nWith question-buses, \\r\\n\\r\\n```lua\\r\\n-- Ghosts:\\r\\numg.answer(\\"rendering:isHidden\\", function(ent)\\r\\n    if ent.ghost and (not canSeeGhosts(playerEnt)) then\\r\\n        -- player cant see ghosts!\\r\\n        return true\\r\\n    end\\r\\n    return false\\r\\nend)\\r\\n\\r\\n\\r\\n-- Potions mod:\\r\\numg.answer(\\"rendering:isHidden\\", function(ent)\\r\\n    if ent.potions and ent.potions[INVISIBILITY] then\\r\\n        -- entity is invisible!!!\\r\\n        return true\\r\\n    end\\r\\n    return false\\r\\nend)\\r\\n```\\r\\n\\r\\nThis idea of \\"delaying\\" behaviour to future mods, is called \\"Delayed Structuring\\", or \\"DELS\\" for short.\\r\\n\\r\\n## But wait!\\r\\nThere are 2 different values being provided here.  \\r\\nHow is the conflict resolved?  \\r\\nAns: We pass in a `combiner` function when we define the question. The `combiner` function is [commutative.](https://en.wikipedia.org/wiki/Commutative_property)   \\r\\nIn this case, we use logical-OR:\\r\\n```lua\\r\\numg.defineQuestion(\\"rendering:isHidden\\", OR_FUNCTION)\\r\\n```\\r\\nLogical-OR makes sense here.   \\r\\n(Consider: If a ghost drank an invisibility potion; it should still be invisible)\\r\\n\\r\\n## But wait! (Episode 2)\\r\\n\\"Why not just create a `.isHidden` component in the rendering mod, and use that???\\"   \\r\\nThe issue with this ^^^ is that it creates *very fragile state*.  \\r\\nWhat happens when the potion wears off? Do we just, set `.isHidden = false`?  \\r\\nIf we do that, it will probably break the ghost system!  \\r\\n(Question buses are a lot better, because they are stateless.)\\r\\n\\r\\n## But wait! (Episode 3)\\r\\n\\"Why not create a `.isHidden` function on the entity?\\"  \\r\\nYes, we *COULD* create a `.isHidden` [shcomp](./2024-04-14_umg_terminology.md), and repeatedly wrap it; but that doesn\'t fit with the ethos of UMG, and doesn\'t fit with the ECS ethos either.  \\r\\nBehaviour should reside in *systems*, not in components.\\r\\n\\r\\n\\r\\n<br/>\\r\\n\\r\\n---\\r\\n\\r\\n## OKAY:\\r\\nWhat you just read was a clear example of DELS in UMG, using question-buses.  \\r\\n\\r\\nAlthough qbuses provide good DELS, they are nothing compared to *event buses.*   \\r\\nRecall:  \\r\\nQuestion bus: Gathers information. Shouldn\'t modify any state.   \\r\\nEvent bus: Dispatches information. Can/should modify state.\\r\\n\\r\\n---\\r\\n\\r\\nAlthough the above example used qbuses, *event-buses* are the ones who carry the real load in UMG;  \\r\\nThis is because the entire control-flow of UMG is routed through a big tree of event calls.\\r\\n\\r\\n(Also, evbuses are quite a bit \\"stronger\\", since they are supposed to modify state, and actually transform the world.)\\r\\n\\r\\nA great example of this is the `health-mod`:\\r\\n```lua\\r\\nlocal function killEntity(ent)\\r\\n    -- kills an entity.\\r\\n    --[[ HMM, other mods may want to know about this, right....? ]]\\r\\n    \\r\\n    ent:delete()\\r\\nend\\r\\n```\\r\\nHere, we should absolutely be using an evbus:  \\r\\n```lua\\r\\n\\r\\nlocal function killEntity(ent)\\r\\n    -- kills an entity.\\r\\n    umg.call(\\"health:entityDeath\\", ent)\\r\\n    --[[\\r\\n        here, we just \\"yeet\\" an event into the void.\\r\\n        Maybe 10 mods will be listening!\\r\\n        Maybe 0 mods are listening.\\r\\n        We dont really care. The main point,\\r\\n        is that we have *DELAYED* the logic for a future mod to handle.\\r\\n    ]]\\r\\n    \\r\\n    ent:delete()\\r\\nend\\r\\n```\\r\\n\\r\\nExample usage:\\r\\n```lua\\r\\numg.on(\\"health:entityDeath\\", function(ent)\\r\\n    if ent.explosive then\\r\\n        -- if entity has `explosive` component, \\r\\n        -- then we should blow up the entity\\r\\n        makeExplosion(ent)\\r\\n    end\\r\\nend)\\r\\n```\\r\\n\\r\\nNow, the *downside*, is that this code will be called by EVERY entity that dies. So the whole setup is very elegant, but also kinda inefficient.  \\r\\nThat\'s fine though; as long as we make sure the checks are sufficiently simple.\\r\\n\\r\\nWe can do more exotic stuff too:\\r\\n```lua\\r\\numg.on(\\"health:entityDeath\\", function(ent)\\r\\n    if ent.username and string.find(ent.username, \\"dave\\") then\\r\\n        -- if entity is being controlled by a `dave`,\\r\\n        -- SHAME DAVE IN ALL-CHAT! LMAO!\\r\\n        chat.globalMessage(\\"[SERVER] dave sucks at videogames\\")\\r\\n    end\\r\\nend)\\r\\n```\\r\\n\\r\\n<br/>\\r\\n\\r\\n## When do we *need* DELS?\\r\\nTo clarify, DELS is just when we NEED some code/functionality in a certain place, but we want to avoid making assumptions about the said piece of code.\\r\\n\\r\\n- We mainly need DELS in base-mods; because base-mods are highly assumptionless.\\r\\n\\r\\n\\r\\n## When do we *NOT need* DELS?\\r\\nWe don\'t need DELS if we are exposing an API, as opposed to systems.  \\r\\nIf we can avoid needing DELS, then that is ideal.\\r\\n\\r\\nFor example, a `math` API shouldn\'t need DELS.  \\r\\nSimilarly, a random-generation library shouldn\'t need much DELS either.  \\r\\n`typecheck` is another example of a mod that doesn\'t really need DELS\\r\\n\\r\\n\\r\\n## Mistaking DELS for direct calls:\\r\\n\\r\\nImagine two mods: `game` and `dep`;   \\r\\nwhere `dep` is a dependency of `game`:  \\r\\n```mermaid\\r\\nflowchart LR\\r\\n    main --\x3e dep\\r\\n```\\r\\nIf `dep` needs something from `game`, then we need DELS.  \\r\\nThis is because `dep` knows NOTHING about `main`; it doesn\'t even know if whether it exists.\\r\\n\\r\\nBut if `main` needs something from `dep`, then there is no problem.  \\r\\nBecause `main` knows everything about `dep` anyway! There\'s no issue here.\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n# *MOST IMPORTANT THING:*\\r\\n# Avoiding DELS:\\r\\nOften, the best course of action is avoid DELS in the first place.  \\r\\n**SERIOUSLY: I CANNOT OVERSTATE THE IMPORTANCE OF THIS STATEMENT!!!**  \\r\\n\\r\\nDELS is used when we ***NEED*** to make an assumption about the system.   \\r\\n(For example; if we need to know whether an entity is hidden or not)\\r\\n\\r\\nIf we can avoid making assumptions in the first place,\\r\\nthen that would be the best course of action.\\r\\n\\r\\nPlease don\'t get into a mindset of \\"use DELS everywhere we can\\".   \\r\\nThis will only lead to bloat, and pain, and a slow rot of the UMG ecosystem.\\r\\n\\r\\n### Avoiding DELS- Example:  \\r\\n- \\"We need `ui` elements to have a size, and position within the main-scene. We can use DELS to provide our elements with size/position\\".\\r\\n\\r\\nNO!! A much better solution, (IMO,) is to instead, allow future-mods to instantiate and control the main-scene themselves.   \\r\\nThis way, they can have full-control over the positioning/sizing of elements.  \\r\\nAlso, future-mods may want to have multiple main-scenes! It\'s way cleaner.\\r\\n\\r\\n\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n\\r\\n## DELS without qbuses / evbuses:\\r\\nCan we do DELS without qbuses / evbuses...???\\r\\n\\r\\nOf course we can!  \\r\\nRemember; event/question buses are just *tools* that we can use to produce good DELS.  \\r\\nIf we want DELS without ev/q buses, we just need to invent new tools / ideas.\\r\\n\\r\\nIf you have a pattern/idea/idiom that you think could produce good DELS in the UMG ecosystem, PLEASE, **PLEASE PLEASE PLEASE** contact me on discord.  \\r\\n(Discord handle: `pakeke`)\\r\\n\\r\\n---\\r\\n\\r\\nThank you for reading! :)"},{"id":"umg_terminology","metadata":{"permalink":"/blog/umg_terminology","source":"@site/blog/2024-04-14_umg_terminology.md","title":"Terminology for UMG","description":"Terminology for UMG.","date":"2024-04-14T00:00:00.000Z","formattedDate":"April 14, 2024","tags":[{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":0.785,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"umg_terminology","title":"Terminology for UMG","tags":["umg"]},"prevItem":{"title":"What is Delayed Structuring? (DELS)","permalink":"/blog/DELS"},"nextItem":{"title":"Avoiding refactoring, and aggressive decoupling","permalink":"/blog/umg_decoupling"}},"content":"Terminology for UMG.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## OKAY:\\r\\nMake sure to update this file as UMG progresses!!!  \\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n\\r\\n# Non-technical terminology:\\r\\n\\r\\n| Word      | Meaning |\\r\\n| ----------- | ----------- |\\r\\n| melt      | A crash, or an error       |\\r\\n| base-mod      | A Mod that serves as a developer\'s toolkit, and is not playable. |\\r\\n| playable-mod      | A Mod that provides a gamemode   |\\r\\n| addon-mod      | A Mod that augments a playable-mod |\\r\\n\\r\\n\\r\\n# Technical terminology inside UMG mods:\\r\\n\\r\\n| Word      | Meaning |\\r\\n| ----------- | ----------- |\\r\\n| qbus   | Question bus |\\r\\n| evbus   | Event bus |\\r\\n| rcomp   | Regular component        |\\r\\n| shcomp  | Shared component        |\\r\\n| ent   | Entity        |\\r\\n| etype   | Entity-Type        |\\r\\n| projection   | Component-projection        |\\r\\n| DELS   | [Delayed-Structuring](../DELS)        |\\r\\n| propagator   | An ent that [references another entity](../ent_propagation)   |\\r\\n| propagatee   | An ent that [is referenced by another entity](../ent_propagation)   |"},{"id":"umg_decoupling","metadata":{"permalink":"/blog/umg_decoupling","source":"@site/blog/2024-04-13_umg_decoupling.md","title":"Avoiding refactoring, and aggressive decoupling","description":"(Rambling and ideas about UMG decoupling, and avoiding future refactors)","date":"2024-04-13T00:00:00.000Z","formattedDate":"April 13, 2024","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"coding","permalink":"/blog/tags/coding"},{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":4.035,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"umg_decoupling","title":"Avoiding refactoring, and aggressive decoupling","tags":["design","coding","umg"]},"prevItem":{"title":"Terminology for UMG","permalink":"/blog/umg_terminology"},"nextItem":{"title":"The Art of Assumptions","permalink":"/blog/art_of_assumptions"}},"content":"(Rambling and ideas about UMG decoupling, and avoiding future refactors)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n### Warning!! This post is quite \\"rambly\\".\\r\\n\\r\\n---\\r\\n\\r\\nI had a *very* interesting conversation with someone in the Love2d discord surrounding decoupling of ECS components.\\r\\n\\r\\nHis opinion was that components should be \\"aggressively decoupled.\\" <br/>\\r\\nFor example; components that work with a position, should store their **OWN** position.   \\r\\nEG:\\r\\n- `sprite` component should OWN a render-position vector\\r\\n- `physics` component should OWN a world-position vector\\r\\n\\r\\nThe idea then, was that an external component would come along, and \\"glue\\" them together, to make positioning consistent.\\r\\n\\r\\nThe reason this is nice, is because if we want to do some fudging-around with the sprite\'s rendering position, (eg, make images bob up and down,) then that is easily doable; since the sprite component\'s position is not coupled to anything.  \\r\\nThis was a really interesting perspective to hear, and I think it opened my mind a lot.\\r\\n\\r\\nNow admittedly, I dislike this specific example; for two reasons:\\r\\n- It makes stuff more complicated\\r\\n- There\'s no longer a single-source of truth for position\\r\\n\\r\\nAlso, in UMG, we can use question-buses within the rendering system to augment the rendering position in a stateless manner; so some of the nasty effects of `image-position` coupling are at least mitigated.\\r\\n\\r\\nBut it was still very interesting !  \\r\\nAnd in general, I think that these *ideas* are still very useful.\\r\\n\\r\\n---\\r\\n\\r\\n## Overall, his ideas are summed up as so:\\r\\n```\\r\\nAlways prefer decoupling, if possible.\\r\\nGlue-code is ALWAYS better than overly-coupled systems.\\r\\n\\r\\nIssues with high-coupling:\\r\\n- hard to extend, manage, very restrictive.\\r\\n\\r\\nIssues with glue-code:\\r\\n- Forgetting to add the glue. OOPSIE! (No problem)\\r\\n\\r\\n```\\r\\n(Obviously, the issues of glue-code are WAY less significant than the issues of a overly-coupled system.)\\r\\n\\r\\n### Downside of decoupling of components:\\r\\nNow, one BIG downside with glue-code, (and aggressive-decoupling,) is that it often generates multiple sources of truth.  \\r\\nThis is kinda just the price we pay.\\r\\n\\r\\n---\\r\\n\\r\\n\\r\\n# Example of good-decoupling in UMG:\\r\\nThe `items` mod, with the `effects` mod.\\r\\nTake the high-level concept: \\r\\n- \\"When player equips helmet, helmet gives +2 armor.\\"\\r\\n\\r\\nAnd the `helmet` entity is represented as an item:\\r\\n```lua\\r\\ndefineItem({\\r\\n\\tpropertyEffect = {\\r\\n\\t\\tarmor = 2\\r\\n\\t},\\r\\n\\tname = \\"Steel Helmet\\",\\r\\n\\t...\\r\\n})\\r\\n```\\r\\n\\r\\nInternally, entities have a list of effects:   \\r\\n- `ent.effects = Effects(...)`   \\r\\nAnd entities can also have an inventory: \\r\\n- `ent.inventory = Inventory(...)`\\r\\n\\r\\nWe would implement this in UMG like so:\\r\\n```lua\\r\\n\\r\\n--[[\\r\\n    Integration with items mod:\\r\\n\\r\\n\\t:onItemAdded is called when itemEnt is added to this slot.\\r\\n\\t:onItemRemoved is called when itemEnt is removed from this slot.\\r\\n\\t:canAddItem checks whether we can add the item.\\r\\n]]\\r\\nlocal HelmetSlot = objects.Class(\\"...\\")\\r\\n    :implement(items.SlotHandle)\\r\\n\\r\\nfunction HelmetSlot:onItemAdded(itemEnt)\\r\\n    local ent = self:getOwner()\\r\\n    if ent.effects then\\r\\n        ent.effects:add(ent, itemEnt)\\r\\n    end\\r\\nend\\r\\n\\r\\nfunction HelmetSlot:onItemRemoved(itemEnt)\\r\\n    local ent = self:getOwner()\\r\\n    if ent.effects then\\r\\n        ent.effects:remove(itemEnt)\\r\\n    end\\r\\nend\\r\\n\\r\\nfunction HelmetSlot:canAddItem(itemEnt)\\r\\n    return isHelmet(itemEnt)\\r\\nend\\r\\n\\r\\n```\\r\\n<br/>\\r\\n\\r\\nThen, inside the inventory;\\r\\n```lua\\r\\n\\r\\nlocal PlayerInventory = objects.Class(\\"...\\")\\r\\n    :implement(items.Inventory)\\r\\n\\r\\nfunction PlayerInventory:init()\\r\\n\\tself:setSlotHandle(1, HelmetSlot())\\r\\nend\\r\\n```\\r\\n\\r\\n\\r\\n# History of UMG:\\r\\nThroughout UMG\'s history, (across the past couple of years,) we have *CONSISTENTLY* created WAY TOO MANY bloaty components.\\r\\n\\r\\nA good example of this is `basicUIComponent`, deployed by the `ui.basics` mod.  \\r\\n`basicUIComponent` is very *meh*, and some other components within `ui.basics` are kinda bad too. These components are tightly coupled to the system that they operate in, which is bad.\\r\\n\\r\\nAs such, I\'m suggesting a new philosophy:\\r\\n\\r\\n## Let the playable-mods define the components.\\r\\n# NOT the base-mods!!! \\r\\n# Base mods should be assumptionless, and pure.\\r\\n\\r\\nIt\'s okay if quick and dirty/hacky components are in playable mods.  \\r\\nBut it is NOT OKAY if dirty/hacky components are in **base** mods.\\r\\n\\r\\nOn a related note, I think that we should try to *minimize* our usage of component-projection.   \\r\\ncomp-projection shares the exact same issues that inheritance has; in that it creates, deep, wide, invisible hierarchies that are kindof hard to understand.\\r\\n\\r\\n---\\r\\n\\r\\n## Mods without components:\\r\\nWe should attempt to have mods/systems like `typecheck`; a mod that defines NO components. \\r\\nOr, a mod like `generation`; which also defines NO components; yet is extremely powerful and useful.\\r\\n \\r\\nInstead of creating many components; focus on creating small, generic components, with *powerful* systems to go alongside them.\\r\\n\\r\\n\\r\\n# Component design ethos:\\r\\nLets sum everything up:   \\r\\n\\r\\n- Keep components small, simple, and meaningful. Components should be small and few; but the systems behind them should be powerful.\\r\\n\\r\\n- Decoupling of components is good. Glue code is better than implicit coupling, (within reason); even if it generates multiple sources of truth.\\r\\n\\r\\n- Its OK to define \\"hacky/bloaty\\" components in Playable mods and Addons. But not in Base mods; base-mods *must* remain clean.\\r\\n\\r\\n- Avoid multi layered component projection in base mods, if possible; (with the obvious exception being flag-components, since they are single layered). Playable/addon mods can have hacky, large spanning projections, since cleanliness doesnt matter as much."},{"id":"art_of_assumptions","metadata":{"permalink":"/blog/art_of_assumptions","source":"@site/blog/2024-03-27_assumptions.md","title":"The Art of Assumptions","description":"I am writing this post, because I don\'t want to make mistakes like this in the future.","date":"2024-03-27T00:00:00.000Z","formattedDate":"March 27, 2024","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"coding","permalink":"/blog/tags/coding"}],"readingTime":4.85,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"art_of_assumptions","title":"The Art of Assumptions","tags":["design","coding"]},"prevItem":{"title":"Avoiding refactoring, and aggressive decoupling","permalink":"/blog/umg_decoupling"},"nextItem":{"title":"What is component-projection?","permalink":"/blog/component_projection"}},"content":"I am writing this post, because I don\'t want to make mistakes like this in the future.  \\r\\nAnd I think that analyzing past mistakes, and attempting to understand them, are a good way to avoid them.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nFor context, I have been working on UMG for about 2.5 years.  \\r\\nAnd throughout this time, over and over, I have made the same mistake of making too many assumptions about the future.\\r\\n\\r\\nWhen I say \\"making an assumption\\", I mean you make a \\"guess\\" about how code/data is going to be used.   \\r\\nAPIs can assume a lot, or can assume not much.  \\r\\n\\r\\nFor example: `math.distance(x, y)`  \\r\\nThis is a highly *assumptionless* API. \\r\\nWe do not know (or CARE) where the `x,y` values are from. We just compute the euclidian distance.\\r\\n\\r\\nAnother example: `uiObject:setBorderColor(color)`  \\r\\nBy contrast, this is an assumption-heavy API.   \\r\\nWe are assuming that `uiObject` has a border.  \\r\\nWe are assuming that the border has a color.  \\r\\nAnd we are also assuming that the `uiObject` can be rendered on the screen!\\r\\n\\r\\nAt face value, there is nothing \\"wrong\\" with this.  \\r\\nAssumptions work really well, *IF* we guess correctly. If every `uiObject` has a border, then this is great!  \\r\\nBut what happens if we want a transparent image as an element?  \\r\\nUH OH... This isn\'t ideal.\\r\\n\\r\\nIt\'d be much better if `uiObject` didn\'t have the `:setBorderColor(color)` method, and instead, we left border-handling to some other system/object.   \\r\\nThis way, we wouldn\'t be left with a weird, bloaty method that is only used for some objects.\\r\\n\\r\\nIn OOP land, this is very similar to the [Interface segregation principle,](https://en.wikipedia.org/wiki/Interface_segregation_principle) which attempts to isolate behaviour across interfaces as much as possible.\\r\\n\\r\\nIn a way, Interface-segregation embodies exactly what I mean by \\"assumptionless-programming\\".  \\r\\nBy splitting things into tiny, hyper-specific interfaces; we are assuming *VERY LITTLE* about the final structure of our objects.  \\r\\nWe are basically admitting to the system: \\"I have no idea what the final objects are going to look like! Thus, I will split the interfaces up as much as possible, so when I implement the concrete classes, the interfaces will fit nicely.\\"\\r\\n\\r\\n---\\r\\n\\r\\nIn UMG, however, we don\'t *often* do OOP; most UMG code is procedural.  \\r\\nSo, what does procedural assumptionless-code look like?  \\r\\nI have some examples up my sleeve from UMG:\\r\\n\\r\\n## Some examples from the UMG ecosystem:\\r\\n\\r\\nPerhaps the most relevant example as of (27/03/2024) is ui.  \\r\\nWith the UI mod, I (stupidly) made an assumption that all root-UI-elements should be rendered in the main-scene.   \\r\\nThis... was really stupid. Because I\'ve now come across a situation where we need to render UI elements directly in the world, rather than in the upper-level main-scene.  \\r\\nTo fix this, we need to remove the assumption that all root-elements exist in the main-scene; and instead, give the programmer the right to choose where the elements are put.  \\r\\n(I know; this seems obvious in hindsight!)\\r\\n\\r\\nAnother example is the inventory system.  \\r\\nA few years ago, I assumed that all inventories would be rendered into the world.   \\r\\nThink like, a chest. Or an anvil. Or a player inventory.   \\r\\nAll of these can be rendered... no problem, right?  \\r\\nNo!!! This is terrible!   \\r\\nWe have created an assumption about *how* the inventory should be rendered. What happens if we want a minecraft-like inventory setup, with a hotbar at the bottom?   \\r\\nUh oh... suddenly, we need *2 different renderers;* one for the hotbar, and one for the inventory. Not possible under our current setup.\\r\\n\\r\\n----\\r\\n\\r\\n<br/>\\r\\n\\r\\n----\\r\\n\\r\\nOk, so it may be obvious by now that \\"highly assumptionless code\\" is a related concept to having [low coupling.](https://en.wikipedia.org/wiki/Coupling_(computer_programming))  \\r\\nWhilst I would agree with this, I think coupling is more often used when talking about the internals of a system; or a system as a whole. When writing an internal system, a lot of the time, you don\'t need to make assumptions about the future; because everything should be contained inside of said system.\\r\\n\\r\\nAssumptions, then, are mostly needed when we are creating an external API, and we are predicting *how* the API is to be used.  \\r\\n[UMG is truly a different beast](../umgtech), for this exact reason. With every base-mod that I write, I am *FORCED* to create assumptions about the future of the platform.  \\r\\nWhich sucks, because my previous code has largely sucked at making good assumptions!!  \\r\\n(I will note, however; that the core UMG-API has been excellent at making no assumptions; so at least I have that haha.)\\r\\n\\r\\nI also want to point out, a piece of software that I think has a very \\"lovely\\" assumptionless structure, is [LOVE](https://love2d.org) itself.  With LOVE, the framework doesn\'t care at all how you structure your game.   \\r\\nThere\'s no such thing as a gameObject. \\r\\nIt doesn\'t care where you put logic.  \\r\\nIt doesn\'t care how you load your files, either.  \\r\\nIsn\'t that beautiful?  \\r\\nAnother API that is highly assumptionless is [Raylib.](https://www.raylib.com/examples.html)\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n\\r\\n# Avoiding bad assumptions in the future:\\r\\nObviously, I want to avoid this shit like the plague.  \\r\\nAs such, I have created a lil checklist/procedure for myself to use.   \\r\\nHere it is:\\r\\n\\r\\n## Checklist for systems:\\r\\n- List (abstractly) all actions (`A`) that this system is doing/performing.\\r\\n    - For every action `A`, can `A` be split up in any way?\\r\\n        - If so, consider splitting it up.\\r\\n    - Also, try make ALL `A`s independent of one another.\\r\\n\\r\\n- List every dependency / bit of coupling `C` that this system is involved with.\\r\\n    - For each `C`, could we remove this coupling whilst maintaining simplicity?\\r\\n\\r\\n## Checklist for components:\\r\\n- Attempt to list all the scenarios that this component could be used in.\\r\\n    - If there are many scenarios; good. Keep it.\\r\\n    - If the list is lacking, consider killing the component, or making it more generic.\\r\\n\\r\\n\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\nThanks for reading; ok, lets hope I remember to try use this thing lol."},{"id":"component_projection","metadata":{"permalink":"/blog/component_projection","source":"@site/blog/2024-03-26_component_projection.md","title":"What is component-projection?","description":"What is component-projection in Untitled Mod Game?","date":"2024-03-26T00:00:00.000Z","formattedDate":"March 26, 2024","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":3.145,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"component_projection","title":"What is component-projection?","tags":["design","umg"]},"prevItem":{"title":"The Art of Assumptions","permalink":"/blog/art_of_assumptions"},"nextItem":{"title":"Heisenbug in UMG!","permalink":"/blog/heisenbug"}},"content":"What is component-projection in Untitled Mod Game?\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n\\"Component-projection\\" is a special feature that I use for my ECS in UMG.\\r\\n\\r\\nIt\'s (kinda?) similar to inheritance in OOP; except, it occurs on components, as opposed to objects.\\r\\n\\r\\nAt it\'s most basic level, component-projection is when one component forces another component to exist, by creating the target component automatically.\\r\\n\\r\\nExample:  \\r\\nLets say we have a generic `drawable` component, that is attached to any entity that is drawable.  \\r\\n\\r\\nWith this, we could have a few different components: \\r\\n```lua\\r\\n-- all things that can be drawn!\\r\\nent.image = \\"monkey.png\\"\\r\\nent.particles = Particles()\\r\\nent.circle = {radius=5}\\r\\n```\\r\\nWith component-projection, we would have each of these components \\"project\\" to the drawable component:\\r\\n```mermaid\\r\\ngraph TD;\\r\\n    image --\x3e drawable\\r\\n    particles --\x3e drawable\\r\\n    circle --\x3e drawable\\r\\n```\\r\\n\\r\\nHow this works in practice, is that entities are automatically granted a `drawable` component IF they have ANY of the listed components.\\r\\n\\r\\nSo when you do this:\\r\\n```lua\\r\\nent.image = \\"bat.png\\"\\r\\n```\\r\\nIt\'s effectively the same as doing:\\r\\n```lua\\r\\nent.image = \\"bat.png\\"\\r\\nent.drawable = true\\r\\n```\\r\\n\\r\\n---\\r\\nThis probably smells very similar to OOP- which makes sense, because it is. Essentially, this is the exact same as an interface in OOP, but in reverse:  \\r\\nWith an OOP interface, the interface *FORCES* methods/fields to be implemented.  \\r\\nWith component-projection, the methods/fields *FORCE* the interface to exist.  \\r\\nIt\'s the same thing, but in reverse.\\r\\n\\r\\n(This is a bit off-topic, but in UMG, we can also use `groups` as component-projection mediums; which allows us to project in more complex ways.)  \\r\\nThat is, we can say stuff like:\\r\\n- \\"If ent has `eyes` component AND `ears` component ->\\"\\r\\n    - \\"give entity `sensory` component\\"\\r\\n\\r\\n<br/>\\r\\n\\r\\n---\\r\\n\\r\\nAnyway, whats AWESOME about all this, is that we can now query entities without knowing about their particular implementation.  \\r\\n\\r\\nFor example:\\r\\n```lua\\r\\n-- Draw System (pseudocode)\\r\\nlocal drawGroup = umg.group(\\"drawable\\", \\"x\\", \\"y\\")\\r\\n\\r\\numg.on(\\"@draw\\", function() {\\r\\n    -- draw all entities!\\r\\n    for ent in drawGroup {\\r\\n        drawEntity(ent)\\r\\n    }\\r\\n})\\r\\n```\\r\\n\\r\\nAnd internally, `drawEntity` would emit some event through some [event bus](../buses), like this:\\r\\n```lua\\r\\nfunction drawEntity(ent) {\\r\\n    -- dispatch `drawEntity` event\\r\\n    umg.call(\\"drawEntity\\", ent)\\r\\n}\\r\\n```\\r\\n\\r\\n```lua\\r\\n-- Other systems listen for `drawEntity` event:\\r\\numg.on(\\"drawEntity\\", function(ent) {\\r\\n    if ent.circle then\\r\\n        drawCircle(ent.x, ent.y, ent.circle)\\r\\n    end\\r\\n})\\r\\n\\r\\numg.on(\\"drawEntity\\", function(ent) {\\r\\n    if ent.image then\\r\\n        drawImage(ent.x, ent.y, ent.image)\\r\\n    end\\r\\n})\\r\\n```\\r\\n\\r\\nWhat\'s also amazing about this setup, is that entities can have ALL of the above components, and they will work perfectly fine.<br/>\\r\\nIs that not beautiful?\\r\\n\\r\\n---\\r\\n\\r\\n## Taking it a step further- Values-projection:\\r\\nWe can take it a step further, by providing *values* for the projected component.  \\r\\nExample:  \\r\\nHere, we see `nametag --\x3e text` projection.  \\r\\n```lua\\r\\ncomponents.project(\\"nametag\\", \\"text\\", function(ent)\\r\\n    local nametag = ent.nametag\\r\\n    -- this returned table will be the VALUE\\r\\n    return {\\r\\n        scale = SCALE,\\r\\n        default = DEFAULT,\\r\\n        component = \\"controller\\",\\r\\n        oy = nametag.oy or EXTRA_OY,\\r\\n        background = BACKGROUND_COLOR,\\r\\n        disableScaling = true\\r\\n    }\\r\\nend)\\r\\n```\\r\\nHere is a code snippet yoinked straight from the umg ecosystem.  \\r\\nWhat\'s special, is that the projection is giving an actual *value* to the target component.  \\r\\nIn this example, the `nametag` component \\"passes\\" a bunch of default values to the `text` component; most notably, it tells the text component to take the value of the `controller` component; (which, notably, will be the username of the player.)\\r\\n\\r\\n<br/>\\r\\n\\r\\n# Pitfalls:\\r\\n**INCONSISTENCY:** If multiple components project to the same component, and they both try to provide a value, only one will succeed. (This is kinda similar to the [diamond-problem in OOP.](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem))\\r\\n\\r\\n**MEMORY EFFICIENCY:** For rcomp projection, its a bit inefficient, since we need to keep track of who is currently projecting to what component in the event of removal. This involves storing an entity in a SSet per projection.\\r\\n\\r\\n**COUPLING:** Creates coupling between 2 components.\\r\\n\\r\\n\\r\\n<br/>\\r\\n<br/>\\r\\n\\r\\n\\r\\nThankz for readin!"},{"id":"heisenbug","metadata":{"permalink":"/blog/heisenbug","source":"@site/blog/2024-02-7_heisenbug.md","title":"Heisenbug in UMG!","description":"Note: This lil rant was written a long time ago; nearly 2 years ago.","date":"2024-02-07T00:00:00.000Z","formattedDate":"February 7, 2024","tags":[{"label":"umg","permalink":"/blog/tags/umg"},{"label":"coding","permalink":"/blog/tags/coding"}],"readingTime":3.23,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"heisenbug","title":"Heisenbug in UMG!","tags":["umg","coding"]},"prevItem":{"title":"What is component-projection?","permalink":"/blog/component_projection"},"nextItem":{"title":"Problem discovery","permalink":"/blog/problem_discovery"}},"content":"**Note: This lil rant was written a long time ago; nearly 2 years ago.**\\r\\n**I\'m deploying on this blog because its funni.**<br/>\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n---\\r\\n\\r\\nSo I was happily programming away one day, refactoring my networking\\r\\ncode, when suddenly, my entity spawning code stopped working.\\r\\n\\r\\nOh no! I probably screwed something up.\\r\\n\\r\\nWell, since I can\'t see anything obvious, and I haven\'t touched this code\\r\\nin a while, lets start from the roots.\\r\\nI checked the client-side, and to no surprise, the entity spawn events\\r\\nwere not being received.\\r\\nOkay- lets have a look at where the event is supposed to be emitted.\\r\\n\\r\\nThis is the code on the server that is responsible for sending entities across:\\r\\n```lua\\r\\n-- on creation of a new entity:\\r\\nlocal pckrdata = cy.serialize_entity(ent)\\r\\nseen[ent] = true\\r\\nconnection.broadcast(\\"ent_spawn\\", pckrdata)\\r\\n```\\r\\n\\r\\nOkay, well, is this code even being ran? \\r\\nLets check by putting a print in there:\\r\\n```lua\\r\\n-- on creation of a new entity:\\r\\nlocal pckrdata = cy.serialize_entity(ent)\\r\\nprint(\\"SENDING ENT SPAWN\\")\\r\\nseen[ent] = true\\r\\nconnection.broadcast(\\"ent_spawn\\", pckrdata)\\r\\n```\\r\\nI run the code, and see a bunch of `SENDING ENT SPAWN` messages in the console.\\r\\nOkay, cool.... \\r\\n\\r\\nBUT WAIT: Now the entities are spawning just fine. The game is literally working.\\r\\nWhat??? What did I change?\\r\\nI go back and delete the print, and the entities stop spawning, and no messages\\r\\nappear in the console.\\r\\n\\r\\n*(This code doesn\'t spawn any entities.)*\\r\\n```lua\\r\\n-- on creation of a new entity:\\r\\nlocal pckrdata = cy.serialize_entity(ent)\\r\\n-- print(\\"SENDING ENT SPAWN\\")\\r\\nseen[ent] = true\\r\\nconnection.broadcast(\\"ent_spawn\\", pckrdata)\\r\\n```\\r\\n\\r\\nWhat is this black magic?!?!?<br/>\\r\\nWhen the print is there, the entities spawn.<br/>\\r\\nWhen the print is not there, the entities *STOP SPAWNING*.\\r\\n\\r\\n<br/>\\r\\n\\r\\n\\r\\n![heisenbug](images/HEISENBUG_2.png)\\r\\n\\r\\n## Oh *no.*\\r\\nIt looks like we are dealing with a notorious [heisenbug!](https://en.wikipedia.org/wiki/Heisenbug)\\r\\n\\r\\nThankfully, it wasn\'t too hard to discover.<br/>\\r\\nHad the bug been non-deterministic, I would have been screwed. \\r\\n\\r\\nIn the end, the solution was \\"somewhat\\" simple... but it requires a bit of background knowledge.\\r\\n\\r\\nFor context, I\'m using [luaJIT](wiki.luajit.org) alongside [ENet](https://leafo.net/lua-enet/) for my networking.\\r\\nWhen I call `print`, luaJIT hits a [NYI function](https://web.archive.org/web/20220717120825/http://wiki.luajit.org/NYI), which causes it to hit a slow path and fall back to interpreted mode *for the entire surrounding trace.*\\r\\n(Note that for luaJIT 2.1 and beyond, a [trace stitching](https://github.com/LuaJIT/LuaJIT/issues/13) feature is introduced, which prevents this, but lets not get beyond ourselves- in the version I was using, `print` breaks JIT for the whole trace.)<br/>\\r\\nIf we pair that with the fact that `print` is pretty slow anyway, then we can be confident that `print` is slowing down our code a lot.\\r\\n\\r\\nI then took a look at the packet frequency per tick on the clientside, and for testing, varied the frequency of packets manually.<br/>\\r\\nResults were so: any more than a few thousands unique packets per frame caused the ENet client to drop the packets.\\r\\n\\r\\nAha! This must be our solution, right? \\r\\n- print breaks JIT\\r\\n- surrounding code cannot be JIT-ed...\\r\\n- Packets are more spaced out, since the server takes longer to complete a tick\\r\\n- Therefore client receives less packets, which the ENet client can handle!\\r\\n\\r\\nTo double check this, I replaced `print` with `io.write`, which happens to keep\\r\\nthe JIT active: I see a bunch of `SENDING ENT SPAWN` in the console, but no\\r\\nentities spawn.\\r\\n\\r\\nGreat- we have our issue. What a funny bug!\\r\\n\\r\\nTo solve this in the end, I wrote code that concatenates packets to reduce the\\r\\npacket frequency.\\r\\nthis seems to work well, and I can send thousands more events across\\r\\nper frame which is nice.\\r\\n\\r\\nI also set up some better tick infrastructure so packets aren\'t being spammed across.\\r\\n\\r\\nIt is a bit sad that the packets are dropped silently though. I\'ll have to bare this in mind for the future- I could see this becoming an issue for a second time if the server is put under a lot of stress."},{"id":"problem_discovery","metadata":{"permalink":"/blog/problem_discovery","source":"@site/blog/2023-10-28_problem_solving.md","title":"Problem discovery","description":"Problem solving is hard! But what I think is harder, is actually problem discovery.","date":"2023-10-28T00:00:00.000Z","formattedDate":"October 28, 2023","tags":[{"label":"opinion","permalink":"/blog/tags/opinion"}],"readingTime":4.535,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"problem_discovery","title":"Problem discovery","tags":["opinion"]},"prevItem":{"title":"Heisenbug in UMG!","permalink":"/blog/heisenbug"},"nextItem":{"title":"Results orientated gamedev, and why it\'s bad","permalink":"/blog/results_orientated_gamedev"}},"content":"Problem solving is hard! But what I think is harder, is actually *problem discovery.*<br/>\\r\\nThis article will be a bunch of rambling about how I like to approach creativity in an engineering context.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nIn my opinion, the hard part is not solving problems:<br/>\\r\\nThe hard part is *recognizing* the problems.<br/>\\r\\nSome kinds of problems are insanely hard to recognize, because we just accept them for what they are. \\r\\n\\r\\nThis is especially apparent for programmers.<br/>\\r\\nAs programmers, we are highly accustomed to working within the limits and constraints of our systems.<br/>\\r\\nAnd with this, I feel like it is very easy to mistake problems for unmoving constraints.\\r\\n\\r\\nThese kind of problems, problems that are mistaken for systemic constraints, I like to call \\"Parasitic problems\\".<br/>\\r\\nParasitic problems aren\'t really apparent at first glance, because our brain mistakes them for unchangable constraints of the system.<br/>\\r\\nThese kind of problems can affect end products *dramatically*.<br/>If we don\'t recognize parasitic-problems, they will sit there *FOREVER*, just beneath our code. Like a dark, invisible parasite, putting a dull tax on efficiency.<br/>\\r\\nAnd what\'s frustrating, is that most of the time, we won\'t notice that these problems even exist, because we mistake them for systemic constraints!\\r\\n\\r\\n--------------\\r\\n\\r\\n# An example: Horses in the Middle ages\\r\\n\\r\\nIf you are a King in the middle ages, and you want to move your army from point-A to point-B as fast as possible, you will send them on horses.\\r\\n\\r\\nBut the issue is that horses can only move so fast!<br/>\\r\\nYour horses can travel about 40 kilometers a day with equipment, but that\'s not fast enough to respond to an invasion force.<br/>\\r\\nAnd we know FOR SURE that *Terry the Terrible* is plotting an invasion right as we speak. \\r\\n\\r\\nOK! What should we do?<br/>\\r\\nWe could do a few things:\\r\\n\\r\\n- Set up a barracks closer to the settlements, and keep some armies there\\r\\n- Train (and equip) the villagers so they can defend themselves\\r\\n- Spread propaganda within enemy territory to prevent an invasion in the first place\\r\\n\\r\\nNice! Ok, these are all valid options.<br/>\\r\\nBut you, (Your majesty,) are missing one crucial detail: You are looking at the *solutions*, not the *problem.*<br/>\\r\\nRememember our original problem: \\"Our armies can\'t respond to invasions in time\\"\\r\\n\\r\\nAnd our primary constraint is that our horses can only travel 40 kilometers per day.<br/>\\r\\nCan we change this?\\r\\n\\r\\nWell of course we can!<br/>\\r\\nIn modern-day, armies travel by air, by train, and by truck.<br/>\\r\\n\\r\\nWith this, we have re-defined our problem:<br/>\\r\\n> \\"Our armies can\'t respond to invasions in time\\"<br/>\\r\\nGets changed to:<br/>\\r\\n> \\"Our armies are moving too slow\\"\\r\\n\\r\\nI\'d like to clarify here. We are not \\"solving\\" a problem. We are RE-DEFINING the problem. With the initial problem, we *assumed* that horse-speeds were a constant constraint.<br/>\\r\\nWith our previous problem-statement, we didn\'t even LOOK for solutions to move our armies faster, since we regarded it as a constraint. This is a great example of a parasitic problem.\\r\\n\\r\\nFor years, the problem of army-movement was locked to the speed of horses. But you, benevolent King, you can change that!<br/>\\r\\nAll you need to do, is invent the amazing *steam engine*, and the *locomotive.*\\r\\n\\r\\n--------------\\r\\n\\r\\n![train_poster](images/train_poster.jpg)\\r\\n\\r\\n--------------\\r\\n\\r\\n## Hold up!\\r\\n\\r\\nSimply \\"inventing trains\\" is no easy feat.<br/>\\r\\nFirst off, how do we know that locomotives are even possible? It\'s easy to say \\"invent X, invent Y\\" in [hindsight](https://en.wikipedia.org/wiki/Egg_of_Columbus), since the brilliant discovery has already been done.\\r\\n\\r\\n(And, before we go further; I\'d like to point out the invention of trains is a pretty bad example to use for this.<br/>\\r\\nWhen you and I go to solve problems in our software, we will generally solve small problems, with small scopes. Going from horses to locomotives is NOT a solution with a small scope.\\r\\nI just wanted to point out- the main reason I used this example is because it\'s very easy to understand.)\\r\\n\\r\\nIn any case, the awkward thing about parasitic problems, is that often, you\'ll be stumbling around blindly.<br/>\\r\\nIf the problem-statement had instead been changed to: \\"How do we find horses that are 100x stronger?\\" then I\'m sure that nothing would have been accomplished; since (biologically) there is so such thing.<br/>\\r\\nBut back then, medieval empires wouldn\'t have known this. It\'s likely that a lot of time was wasted trying to solve the \\"problem\\" of finding/creating giant horses!\\r\\n\\r\\n-------------\\r\\n\\r\\n![big_moose](images/giant_moose_army.png)\\r\\n\\r\\n------------\\r\\n\\r\\nQuite frankly, this is the trouble with \\"solving\\" parasitic-problems.<br/>\\r\\nRemember that a parasitic-problem is just a constraint *redefined* as a problem. We haven\'t actually solved anything; and we don\'t know if a solution is possible.<br/>\\r\\nIt\'s entirely possible that the problem is actually a hard constraint.\\r\\n\\r\\n-------------------\\r\\n\\r\\n# Solving parasitic-problems accidentally:\\r\\n\\r\\nI also think that toying around with random ideas is underrated. When I came up with the idea for [question buses](../buses), I wasn\'t attempting to \\"solve\\" any problem, I was just curious as to what event-buses would look like if the data flow was reversed.<br/>\\r\\nAnd as it turned out, question-buses have completely transformed the project.\\r\\n\\r\\nThis was the same with the load-time entityType mutation API. (Ie. UMG\'s `@newEntityType` callback; naming may be different.)\\r\\nWith this, I wasn\'t actually looking to solve anything, I was just toying around with ideas. As soon as the API existed, the problems that it solved materialized into existance- from unseen-constraints, to a set of parasitic-problems that could be solved easily with this new setup.\\r\\n\\r\\n-----\\r\\n\\r\\nThanks for reading this opinion piece!"},{"id":"results_orientated_gamedev","metadata":{"permalink":"/blog/results_orientated_gamedev","source":"@site/blog/2023-10-04_results_orientated.md","title":"Results orientated gamedev, and why it\'s bad","description":"I think that developing games purely from a results-orientated perspective is bad.","date":"2023-10-04T00:00:00.000Z","formattedDate":"October 4, 2023","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"opinion","permalink":"/blog/tags/opinion"}],"readingTime":3.92,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"results_orientated_gamedev","title":"Results orientated gamedev, and why it\'s bad","tags":["design","opinion"]},"prevItem":{"title":"Problem discovery","permalink":"/blog/problem_discovery"},"nextItem":{"title":"UMG Idioms","permalink":"/blog/umgidioms"}},"content":"I think that developing games purely from a results-orientated perspective is bad.\\r\\nThis article will explain my reasoning, and is a successor to [my other article on emergence.](../emergence)\\r\\n\\r\\n\x3c!-- truncate --\x3e\\r\\n\\r\\nThis article will discuss the difference between 2 development methods:\\r\\n- \\"Results orientated development\\"\\r\\n- and \\"Systems orientated development\\"\\r\\n\\r\\n\\r\\nWhen I say a development cycle is \\"results orientated\\", I mean that the developers start with the player interactions/gameplay in mind, and develop the product from there.\\r\\n\\r\\n------------------\\r\\n\\r\\nTake for example, this development cycle:\\r\\n- \\"We want gameplay where the players shoot zombies, and build fortifications to defend against zombies\\".\\r\\n\\r\\nOk.<br/>\\r\\nWith this goal in mind, the development cycle will continue as expected... When the cycle is finished, we will have a basic product. Players will be able to build fortifications, and use their guns to fend off the waves of undead.<br/>\\r\\n\\r\\nBut the problem with this setup is that we have (probably) created a highly one-dimensional setup.<br/>\\r\\nDoes it matter if we have hordes of undead to fight, if our systems aren\'t good?\\r\\n\\r\\nWhen I talk \\"systems\\", I don\'t mean invisible architecture; I mean real systems that the player can observe and intuitively interact with.<br/>\\r\\nThe building/fortification system is great! cool! But did we implement it in a way that gives depth, *beyond* the closed scope of the development cycle?<br/>\\r\\nSure, our fortifications are great at dealing with zombies! But next update, we are adding multiplayer. Will our fortifications be able to deal with an onslaught of raiders from the other side of the server?<br/>\\r\\nMaybe! But even if they *do* succeed in fending off player raiders, they weren\'t meant to, and we got lucky.<br/>\\r\\nAnd this is our problem.\\r\\n\\r\\nIt would be much better if we started off with a more generic goal, and started development from a *systems orientated* perspective.\\r\\n\\r\\nFor example:\\r\\n- \\"We want a system where the player can manipulate structures to serve their goals\\"\\r\\n\\r\\nAlready, this looks way more promising.<br/>\\r\\nLets ignore zombies. Lets ignore raiders. Lets just give our players the *tools* to create and manipulate structures in a comprehensive fashion. From there, whatever other systems/mechanics we may add in the future, they are guaranteed to mesh well with our building system, since we made our system open ended.\\r\\n\\r\\nI call this, \\"systems orientated\\" development.\\r\\n\\r\\n-----------------\\r\\n\\r\\n# Chess!\\r\\n\\r\\n![chess](images/chess2.jpg)\\r\\n\\r\\n----------------\\r\\n\\r\\nChess is epic.<br/>\\r\\nIt\'s one of the best games to ever exist. And it\'s popularity proves it.\\r\\n\\r\\nChess was a game that was developed from a \\"systems orientated\\" perspective, as opposed to a \\"results orientated\\" perspective.\\r\\n\\r\\n-------\\r\\n\\r\\nOk! Lets have a look at some of the core mechanics of chess, and lets imagine what Chess would look like if it was developed with the end-result in mind.\\r\\n\\r\\n--------\\r\\n\\r\\n**Forks.** <-- These things [are an important part of chess.](https://en.wikipedia.org/wiki/Fork_(chess))<br/>\\r\\nHowever, lets stop to ponder.\\r\\n\\r\\nThe genius cavemen who created chess... did they develop chess with forks in mind? \\r\\n\\r\\n- **Caveman Bob:** \\"Hey Caveman Fred. You know what I want? I want a game where there are [PINS](https://en.wikipedia.org/wiki/Pin_(chess)), and [FORKS!](https://en.wikipedia.org/wiki/Fork_(chess))\\"\\r\\n- **Caveman Fred:** \\"That sounds like a GREAT idea!\\"\\r\\n\\r\\nSo I can guarantee that this never happened.<br/>\\r\\nWhy? Well, because forks and pins *don\'t exist outside of chess.*<br/>\\r\\nThey were created as a result of chess\'s amazing systems.\\r\\n\\r\\nIf we try to create truly interesting/emergent gameplay from a results-orientated perspective, we will fail. Because the most interesting game mechanics simply *don\'t exist*, unless the systems exist to back them up.\\r\\n\\r\\nConsider:\\r\\n- **Caveman Bob:** \\"How about we make a game where positional strategy is really important?\\"\\r\\n- **Caveman Fred:** \\"OK!\\"\\r\\n- **Caveman Bob:** \\"Hmm. We need a system where pieces can link up and connect with each other.\\"\\r\\n- **Caveman Fred:** \\"What if pieces can capture other pieces? That way, by positioning your pieces, you can protect them.\\"\\r\\n\\r\\nFrom there, Fred and Bob would go on to create the most influential game in human history, (besides Go).\\r\\n\\r\\nNote that they didn\'t start with a direct end goal in mind. They started with a vague idea for an interesting concept.<br/>\\r\\nBob and Fred developed chess from a *systems-orientated* perspective. And as a result, pins and forks were implemented for *free*, which are super important gameplay elements in chess.\\r\\n\\r\\nAnd that\'s pretty much my main point.\\r\\n\\r\\nI know, it feels weird. It feels dumb. My inner project-manager is enraged!<br/>\\r\\nBut I truly believe that developing systems, and having [systematic emergence](../emergence) in games is **way more important** than having a direct end-result that you can work towards.\\r\\n\\r\\n---------------\\r\\n\\r\\nGood gameplay cannot create systems, but good systems can create gameplay.<br/>\\r\\nIn my opinion, that sums up why I think it\'s good to approach gamedev from a systems-orientated perspective.\\r\\n\\r\\nThank you for reading! :)"},{"id":"umgidioms","metadata":{"permalink":"/blog/umgidioms","source":"@site/blog/2023-09-30_umg_idioms.md","title":"UMG Idioms","description":"A list of idioms for the UMG ecosystem.","date":"2023-09-30T00:00:00.000Z","formattedDate":"September 30, 2023","tags":[{"label":"coding","permalink":"/blog/tags/coding"},{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":5.5,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"umgidioms","title":"UMG Idioms","tags":["coding","umg"]},"prevItem":{"title":"Results orientated gamedev, and why it\'s bad","permalink":"/blog/results_orientated_gamedev"},"nextItem":{"title":"How should we represent entity properties?","permalink":"/blog/properties"}},"content":"A list of idioms for the UMG ecosystem.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n-----------------\\r\\n<br/>\\r\\n\\r\\n# Checking if an entity has a component:\\r\\n```lua\\r\\nif ent.foo then\\r\\n    print(\\"entity has component foo!\\")\\r\\nend\\r\\n```\\r\\nThis is (roughly) the same as `ent:hasComponent(\\"foo\\")`.<br/>\\r\\n(This works because lua tables give nil when a key is missing)\\r\\n\\r\\n------------------\\r\\n<br/>\\r\\n\\r\\n# Runtime client/server checks:\\r\\nOften, we will have code that is running on BOTH client-side AND server-side.<br/>\\r\\n(For example, the `onDeath` callback)\\r\\n\\r\\nTo get server/client specific behaviour, we can check what side we are on at runtime!\\r\\n```lua\\r\\nlocal function onDeath(ent)\\r\\n    -- called on client AND server.\\r\\n    if server then\\r\\n        -- this branch is only ran on server.\\r\\n        print(\\"I AM FROM SERVER\\")\\r\\n    elseif client then\\r\\n        -- only ran on client! :)\\r\\n        print(\\"hi from client!\\")\\r\\n    end\\r\\nend\\r\\n```\\r\\nYou get the idea! :)\\r\\n\\r\\n------------------\\r\\n<br/>\\r\\n\\r\\n\\r\\n# Client/server only shared components:\\r\\nSometimes, we will have an object that can only be created on client/server. (For example, a text object)  \\r\\nThe issue is that text objects don\'t exist on the server.  and we may want this object as a shared component in an ent-type definition.  \\r\\nHow do we fix this?    \\r\\n\\r\\nWe can avoid this with the following idiom:\\r\\n```lua\\r\\numg.defineEntityType(\\"mod:myEnt\\", {\\r\\n    text = client and Text()\\r\\n    --[[\\r\\n    Due to short circuiting, Text() is only evaluated on the client here.\\r\\n    if we justpdid:\\r\\n\\r\\n    text = Text()\\r\\n\\r\\n    Then we would get an error, because Text is not available on the server.\\r\\n    ]]\\r\\n})\\r\\n```\\r\\n\\r\\n-----\\r\\n<br/>\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n# Classes:\\r\\nLua doesn\'t have classes, neither does the UMG engine.<br/>\\r\\nHowever, the `objects` base mod provides classes:\\r\\n```lua\\r\\nlocal MyClass = objects.Class(\\"my_mod:MyClass\\")\\r\\n\\r\\nfunction MyClass:init(...)\\r\\n    -- init is a special function that is called on instantiation\\r\\n    print(\\"init!\\", ...)\\r\\nend\\r\\n\\r\\nfunction MyClass:method()\\r\\n    print(\\"method call: \\", self)\\r\\nend\\r\\n\\r\\nlocal obj = MyClass(1,2,3)\\r\\n-- prints:  init! 1 2 3\\r\\n```\\r\\nThe reason this is better than `setmetatable`, is because `objects.Class` \\r\\nwill automatically register `MyClass` with `umg.register`.\\r\\n\\r\\n(WARNING: When defining a class, make sure to define on BOTH client AND server!!!\\r\\nElse, you\'ll run into big bad issues.)\\r\\n\\r\\n----------------\\r\\n<br/>\\r\\n\\r\\n\\r\\n# Component-wise bus response:\\r\\nListen to an event/question, and only respond if the entity has a certain component:<br/>\\r\\nThis setup is VERY common (and important) in UMG.\\r\\n\\r\\n- If an entity has the `.halo` component:\\r\\n    - --\x3e draw a circle above it.\\r\\n```lua\\r\\numg.on(\\"rendering:drawEntity\\", function(ent)\\r\\n    if ent.halo then\\r\\n        -- draw a halo above the entity!\\r\\n        love.graphics.circle(\\"line\\", ent.x, ent.y - 10, 5)\\r\\n    end\\r\\nend)\\r\\n```\\r\\n\\r\\nComp-wise bus response also works with question buses too:\\r\\n- If an entity is covered in goo:\\r\\n    - --\x3e slow the entity\\r\\n```lua\\r\\numg.answer(\\"xy:getSpeedMultiplier\\", function(ent)\\r\\n    if ent.goo then\\r\\n        return 0.5\\r\\n    end\\r\\n    return 1\\r\\nend)\\r\\n```\\r\\n\\r\\n------------------\\r\\n<br/>\\r\\n\\r\\n# Entity inheritance:\\r\\nSometimes, we may want to define an entity \\"base class\\", and extend it for a bunch of similar entity-types.\\r\\n\\r\\nWe can do this by defining a function that mutates an entity definition:\\r\\n```lua\\r\\n-- shared/abstract_entities.lua\\r\\n\\r\\n-- make sure its global!\\r\\nfunction enemyType(etype)\\r\\n    etype.category = \\"enemy\\",\\r\\n    etype.attack = etype.attack or {\\r\\n        type = \\"melee\\",\\r\\n        range = MELEE_RANGE\\r\\n    };\\r\\nend\\r\\n```\\r\\nAnd then, when we define our entities, we can access our global function `enemyType`:\\r\\n```lua\\r\\n-- entities/my_enemy.lua\\r\\n\\r\\nreturn enemyType({\\r\\n    image = \\"enemy1\\",\\r\\n    baseMaxHealth = 100,\\r\\n    baseStrength = 30\\r\\n})\\r\\n```\\r\\nYou get the idea :)\\r\\n\\r\\n\\r\\n------------------\\r\\n<br/>\\r\\n\\r\\n# Functions in components:\\r\\nYou may be horrified to realize that in UMG, doing this on serverside will cause a runtime error:\\r\\n```lua\\r\\nent.myComponent = function() end\\r\\n```\\r\\nThis is because in UMG, newly defined components are automatically sent over the network.<br/>\\r\\nAnd in UMG, functions can\'t be serialized; so an error is thrown.\\r\\n\\r\\nBut we *can* have functions as shared components, by defining them inside the entity type.<br/>\\r\\nThis is because shared-components aren\'t sent over the network.\\r\\n```lua\\r\\n-- my_mod/entities/my_entity.lua\\r\\nreturn {\\r\\n    myComponent = function() end\\r\\n    -- this is ok! :)\\r\\n\\r\\n    ...\\r\\n}\\r\\n```\\r\\n\\r\\n\\r\\n-----------------\\r\\n<br/>\\r\\n\\r\\n# Typecheck naming convention:\\r\\nWhen using `typecheck` mod, it\'s common to end the typecheck function with `Tc`.<br/>\\r\\nFor example:\\r\\n```lua\\r\\nlocal addTc = typecheck.assert(\\"number\\", \\"number\\")\\r\\n```\\r\\n(The `Tc` stands for \\"type check\\")\\r\\n\\r\\n-----------------------\\r\\n<br/>\\r\\n\\r\\n# Method-Event pattern in base mods:\\r\\nWhen an event happens concerning an entity, it\'s common to do something like this:\\r\\n```lua\\r\\n-- ent dies!\\r\\nlocal function die(ent)\\r\\n    if ent.onDeath then\\r\\n        ent:onDeath()\\r\\n    end\\r\\n    umg.call(\\"mod:onDeath\\", ent)\\r\\nend\\r\\n```\\r\\n\\r\\nThis is quite flexible, since it allows for other systems to tag onto the death event, but it also allows entity-specific behaviour through our `onDeath` shared component.\\r\\n\\r\\nExamples of this: `mortality:entityDeath`, `rendering:drawEntity`\\r\\n\\r\\n\\r\\n------\\r\\n<br/>\\r\\n\\r\\n# Component-projection  +  Flag components:\\r\\nIn UMG, \\"component projection\\" is a concept when one component causes\\r\\nanother component to exist, or \\"creates\\" another component.\\r\\n\\r\\nThe `components` base mod provides a bunch of tools for this:\\r\\n```lua\\r\\ncomponents.project(\\"X\\", \\"Y\\")\\r\\n-- Component X \\"projects\\" onto component Y.\\r\\n\\r\\n-- (Any entities that with component `X` are given component `Y`)\\r\\n```\\r\\nThis is most common for \\"flag\\" components; ie. components that don\'t do anything on their own, but cause the entity to be accepted by certain systems.<br/>\\r\\nExample:\\r\\n```lua\\r\\n\\r\\ncomponents.project(\\"clickToBuy\\", \\"clickable\\")\\r\\n-- any entity with `clickToBuy` will be given the `clickable` component\\r\\n\\r\\numg.on(\\"control:entityClicked\\", function(ent)\\r\\n    --[[\\r\\n    The only reason this event is emitted, is because ent has the\\r\\n    `clickable` component, and is being handled by the `clickable` system!\\r\\n\\r\\n    We don\'t need to worry about how the clickable system works;\\r\\n    we just need to listen to this callback.\\r\\n    ]]\\r\\n    if ent.clickToBuy then\\r\\n        shop.tryBuy(ent)\\r\\n    end\\r\\nend)\\r\\n```\\r\\nThe same thing is used for `drawable` and `usable`.\\r\\n\\r\\n\\r\\n-----\\r\\n<br/>\\r\\n\\r\\n# Component referencing:\\r\\nSometimes, we want a component to have behaviour that depends on other (arbitrary) components.\\r\\n\\r\\nFor example, Health-Bars should depend on both `maxHealth` and `health` components.\\r\\n\\r\\nUsing component-referencing, we could implement Health-Bars using a more generic component: Progress-Bars!\\r\\n```lua\\r\\n-- We create a healthBar,\\r\\n-- USING the progressBar component:\\r\\nent.progressBar = {\\r\\n    value = \\"health\\", -- value of the progressBar\\r\\n    maxValue = \\"maxHealth\\", -- max-value of the progressBar\\r\\n\\r\\n    color = RED\\r\\n}\\r\\n```\\r\\nHere, the system that manages the `progressBar` component will notice that we want the *value* of the progressBar to be determined by `ent.maxHealth` and `ent.health`.\\r\\n\\r\\nThis is *really* beautiful, since we can reuse progressBars to represent other stuff.<br/>\\r\\nFor example, a timer:\\r\\n```lua\\r\\n-- A timer! :)\\r\\nent.progressBar = {\\r\\n    value = \\"timeRemaining\\",\\r\\n    maxValue = \\"totalTime\\"\\r\\n}\\r\\n-- Using `ent.totalTime` and `ent.timeRemaining` components.\\r\\n```\\r\\nWe could then combine this with component projection to make a proper `healthBar` component:\\r\\n```lua\\r\\ncomponents.project(\\"healthBar\\", \\"progressBar\\", function(ent)\\r\\n    --[[\\r\\n        healthBar component projects ONTO progressBar component\\r\\n        (healthBar --\x3e progressBar)\\r\\n    ]]\\r\\n    local hBar = ent.healthBar\\r\\n\\r\\n    local progressBar = {\\r\\n        value = \\"health\\",\\r\\n        maxValue = \\"maxHealth\\",\\r\\n        color = RED,\\r\\n        width = hBar.width,\\r\\n        height = hBar.height\\r\\n    }\\r\\n    return progressBar\\r\\nend)\\r\\n```\\r\\nAwesome, right??? :D\\r\\n\\r\\n\\r\\n----\\r\\n<br/>"},{"id":"properties","metadata":{"permalink":"/blog/properties","source":"@site/blog/2023-09-23_properties.md","title":"How should we represent entity properties?","description":"How should properties be represented in video games?","date":"2023-09-23T00:00:00.000Z","formattedDate":"September 23, 2023","tags":[{"label":"coding","permalink":"/blog/tags/coding"},{"label":"design","permalink":"/blog/tags/design"}],"readingTime":4.385,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"properties","title":"How should we represent entity properties?","tags":["coding","design"]},"prevItem":{"title":"UMG Idioms","permalink":"/blog/umgidioms"},"nextItem":{"title":"Common lua idioms","permalink":"/blog/luaidioms"}},"content":"How should properties be represented in video games?<br/>\\r\\nI.e, maxHealth, damage, speed?\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nThe naive approach is to directly mutate the value:\\r\\n```lua\\r\\nent.damage = 5\\r\\n\\r\\n-- If we want to increase/decrease damage, just add/subtract:\\r\\nent.damage += 5 -- increase \\r\\nent.damage -= 5 -- decrease :) \\r\\n```\\r\\n\\r\\nBut this approach falls apart as soon as we add damage modifiers:\\r\\n```\\r\\nIf ent inside circle\\r\\n    gain 2 dmg\\r\\n```\\r\\nSuddenly, we have to increase/decrease `ent`s damage every time we enter/exit the circle.<br/>\\r\\nAnd it gets a bit mucky... What happens if we have these two rules:\\r\\n```\\r\\nIf ent inside circle\\r\\n    gain 2 dmg\\r\\n\\r\\nIf ent inside square\\r\\n    multiple dmg by 2\\r\\n```\\r\\nNow imagine the following events:\\r\\n```\\r\\nent dmg = 5\\r\\n\\r\\nent enters circle (dmg = 5+2 = 7)\\r\\nent enters square (dmg = 7*2 = 14)\\r\\nent leaves circle (dmg = 14-2 = 12)\\r\\nent leaves square (dmg = 12/2 = 6)\\r\\n\\r\\nent dmg = 6\\r\\n```\\r\\nUh oh!<br/>\\r\\nYeah we clearly need a smarter system.\\r\\n\\r\\n# Ok. How should we do it then?\\r\\n\\r\\nLets create some ideas!\\r\\n\\r\\n-----------\\r\\n\\r\\n## Modifier list\\r\\n\\r\\nIDEA: Have a list of `damageAdders` and `damageMultipliers` for our property.\\r\\n```\\r\\nent dmgMultipliers = []\\r\\nent dmgAdders = []\\r\\n```\\r\\n\\r\\nThis approach would involve having \\"modifiers\\" to the entity property, and when the entity\'s modifiers are changed, recalculate the property value.\\r\\n\\r\\nRecall our circle/square example:\\r\\n```\\r\\nent enters circle and square:\\r\\ndmgMultipliers = [2] \\r\\ndmgAdders = [2] \\r\\nrecalculation -> dmg = 14\\r\\n\\r\\nent exits:\\r\\ndmgMultipliers = [] \\r\\ndmgAdders = [] \\r\\nrecalculation -> dmg = 5\\r\\n```\\r\\n\\r\\nNow, TBH, I\'m really not a fan of this solution...<br/>\\r\\nMainly because the damage modifiers have to be added AND THEN removed. If we forget to remove it, then we\'re screwed!<br/>\\r\\nThis is due to it being stateful. I personally try to avoid state when I can.\\r\\n\\r\\n**PROS:**\\r\\n- Efficient: Only recalculates when something changes \\r\\n\\r\\n**CONS:**\\r\\n- Stateful, fragile\\r\\n\\r\\n------------\\r\\n\\r\\n\\r\\n## Recalculate per tick\\r\\nIf we have our damage system recalculate the entity\'s damage each tick,\\r\\nthen we don\'t need to worry about state, and our issues are solved.\\r\\n\\r\\nThat would look something like:\\r\\n```lua\\r\\neachTick(function() {\\r\\n    for ent in damageEntities {\\r\\n        ent.damage = calculateDamage(ent)\\r\\n    }\\r\\n})\\r\\n\\r\\nfunction calculateDamage(ent) {\\r\\n    dmg = ent.baseDamage\\r\\n    for shape in shapeList {\\r\\n        if shape.contains(ent) {\\r\\n            dmg += shape.getBuff(ent, :damage)\\r\\n        }\\r\\n    }\\r\\n    ... -- other calculations here\\r\\n    return dmg\\r\\n}\\r\\n```\\r\\n\\r\\nHowever, the main glaring \\"downside\\" with this approach is that damage values could be incorrect. Take the following example:\\r\\n\\r\\n- Every time I shoot a bullet, gain +2 damage for 5 seconds\\r\\n    - shoots 10 bullets in one tick\\r\\n    - --\x3e uh oh! All 10 bullets have the same damage!\\r\\n\\r\\n**PROS:**\\r\\n- No statefulness\\r\\n\\r\\n**CONS:**\\r\\n- Not the best for performance\\r\\n- Damage values may be incorrect, since it only refreshes per tick\\r\\n\\r\\n---------------------\\r\\n\\r\\n## Recalculate whenever\\r\\n\\r\\nTo avoid the above problem, we can recalculate more often.<br/>\\r\\nHow about we recalculate damage every time we need it? i.e:\\r\\n```lua\\r\\nfunction shootBullet(ent) {\\r\\n    dmg = calculateDamage(ent) -- same function as above.\\r\\n    bullet = newBullet(dmg)\\r\\n}\\r\\n```\\r\\nThis way, if we shoot 10 bullets, then our bullets are guaranteed to have the correct damage values.<br/>\\r\\nThe *downside* is that we are now having to recalculate every time we shoot. Not ideal!\\r\\n\\r\\nLikewise, whenever we want to even *access* the damage property, we must recalculate. That could be pretty bad; but again, it depends on how complex our damage recalculation setup is.\\r\\n\\r\\n**PROS:**\\r\\n- No statefulness\\r\\n- Guaranteed accuracy\\r\\n\\r\\n**CONS:**\\r\\n- Performance can be GARBO, depending on our setup\\r\\n\\r\\n-------------\\r\\n\\r\\n\\r\\n## Calculation tree + cache:\\r\\n\\r\\nImagine that we are recalculating the property every time we access it.<br/>\\r\\nLets say we have benchmarked our program, and we are running into performance issues due to our Shield system. Our shield system is really complicated, and it requires querying over a bunch of other entities when recalculating.\\r\\n\\r\\nWhat we could do here is split our setup into a tree:<br/>\\r\\nIn this example, the `damage` system is querying a bunch of calculator systems to obtain `damage`.\\r\\n\\r\\n```mermaid\\r\\nstateDiagram-v2\\r\\n    damage  --\x3e  shieldCalculator\\r\\n    damage  --\x3e  itemCalculator\\r\\n    damage  --\x3e  potionCalculator\\r\\n```\\r\\n\\r\\n-------------------\\r\\n\\r\\nWith this setup, we can convert the `shieldCalculator` system into a per-tick system, and add internal caching for efficiency.<br/>\\r\\nThis way, the other 2 systems (potions and items) can remain accurate, and it\'s only the shields that are slightly out of date.\\r\\n\\r\\nIf we STILL run into performance issues, we can recalculate shields every 5 ticks instead, for example.\\r\\n\\r\\nLikewise, if the potion system has a particular potion class that is problematic for performance, then the potion system could split itself up, and do some internal caching on \\"complex potions\\" to account:\\r\\n\\r\\n-------------------\\r\\n\\r\\n```mermaid\\r\\nstateDiagram-v2\\r\\n    damage  --\x3e  shieldCalculator\\r\\n    damage  --\x3e  itemCalculator\\r\\n    damage  --\x3e  potionCalculator\\r\\n    potionCalculator --\x3e normalPotions\\r\\n    potionCalculator --\x3e complexPotions\\r\\n```\\r\\n\\r\\n--------------\\r\\n\\r\\nWhat\'s cool, is that *all three* previous approaches work perfectly well with this tree setup.\\r\\n\\r\\nPerhaps the effect system already has some internal state upon entities? In that case, there would be no downside to the `Modifier list` approach.<br/>\\r\\nWe can have our cake, and eat it too.\\r\\n\\r\\n--------------\\r\\n\\r\\nTo understand to how the damage calculation system has been implemented in [UMG](../umgtech), take a look at [my article on question buses.](../buses)\\r\\n\\r\\nThanks for reading!\\r\\n- Oli"},{"id":"luaidioms","metadata":{"permalink":"/blog/luaidioms","source":"@site/blog/2023-09-22_idiomatic_lua.md","title":"Common lua idioms","description":"I have been using lua for a while. (About 4 years as of writing this!)","date":"2023-09-22T00:00:00.000Z","formattedDate":"September 22, 2023","tags":[{"label":"coding","permalink":"/blog/tags/coding"}],"readingTime":2.305,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"luaidioms","title":"Common lua idioms","tags":["coding"]},"prevItem":{"title":"How should we represent entity properties?","permalink":"/blog/properties"},"nextItem":{"title":"UMG has no versioning","permalink":"/blog/versioning"}},"content":"I have been using lua for a while. (About 4 years as of writing this!)<br/>\\r\\nIt\'s a language that I kinda grew up on, and I\'ve learned to love.<br/>\\r\\nThis article will contain a list of idioms that are common to see in lua.<br/>\\r\\nLets go!\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## Default values with `or`\\r\\n```lua\\r\\nlocal x = obj.x or 15\\r\\n-- in lua, accessing an undefined table value defaults to `nil`.\\r\\n-- `nil` and `false` are falsey values,\\r\\n-- So in this example,\\r\\n-- If `obj` doesnt have the `.x`, then it will fall back to 15.\\r\\n\\r\\n-- another common use case:\\r\\nobj.x = obj.x or 0\\r\\n\\r\\n```\\r\\n\\r\\n----------------\\r\\n\\r\\n## Optional arguments:\\r\\n\\r\\nIn lua, passing less or more arguments doesn\'t error.\\r\\n```lua\\r\\nlocal function f(x)\\r\\n    print(x)\\r\\nend\\r\\n\\r\\nf(1,2,3) -- this is fine. output: 1\\r\\nf() -- this is fine. output: nil\\r\\n```\\r\\n\\r\\nWe can use this to have optional arguments:\\r\\n```lua\\r\\n-- euclidean distance:\\r\\nlocal function distance(x, y, z)\\r\\n    z = z or 0 -- z is an optional argument!\\r\\n    local dx, dy, dz = x*x, y*y, z*z\\r\\n    return (dx+dy+dz) ^ 0.5\\r\\nend\\r\\n\\r\\n\\r\\nprint(distance(3,4)) -- 5\\r\\nprint(distance(3,4,5)) -- 7.071\\r\\n```\\r\\n\\r\\n---------------\\r\\n\\r\\n## Error on undefined access\\r\\n\\r\\nIn lua, if you access an undefined variable, that variable returns nil.\\r\\nExample:\\r\\n```lua\\r\\nprint(undefined_variable_34389439) -- nil\\r\\n-- no error!\\r\\n```\\r\\nThis is a bit weird, and some people don\'t like it.<br/>\\r\\nBut we can change this with `__index` and `setmetatable`.\\r\\n\\r\\nIn lua, `_G` is the special table that holds all the globals.\\r\\n```lua\\r\\nlocal function err(t,k,v)\\r\\n    error(\\"Accessed an undefined variable: \\" .. tostring(k))\\r\\nend\\r\\nsetmetatable(_G, {\\r\\n    __index = err\\r\\n})\\r\\n```\\r\\nNow, if we access an undefined variable:\\r\\n```lua\\r\\nprint(undefined_variable_34389439)\\r\\n-- Error: main.lua:4:\\r\\n-- Accessed an undefined variable: undefined_variable_34389439\\r\\n```\\r\\n\\r\\nYou can do the same with `__newindex` if you want to stop pollution of the global namespace on accident.\\r\\n\\r\\n------------------\\r\\n\\r\\n## Private class methods\\r\\nFor the OOP folks out there, who want private methods.\\r\\n\\r\\nOften in lua, you\'ll see a class setup like so:\\r\\n\\r\\n```lua\\r\\nlocal MyClass = Class()\\r\\n\\r\\nfunction Class:init()\\r\\n    self.x = 0; self.y = 0\\r\\nend\\r\\n\\r\\nfunction Class:privateHi()\\r\\n    -- ugh, I wish this could be private!\\r\\n    print(self)\\r\\nend\\r\\n\\r\\nfunction Class:hi()\\r\\n    self:privateHi()\\r\\n    print(\\"hiiii\\")\\r\\nend\\r\\n```\\r\\nPrivate methods can be done like so.\\r\\n```lua\\r\\n\\r\\nlocal function privateHi(self)\\r\\n    -- yay, now i am private!\\r\\n    print(self)\\r\\nend\\r\\n\\r\\nfunction Class:hi()\\r\\n    privateHi(self)\\r\\n    print(\\"hiiii\\")\\r\\nend\\r\\n```\\r\\nAt first, you may feel uneasy doing it this way, or you may feel cheated.<br/>\\r\\nRealize though, that all functions in lua are anonymous and first-class. `privateHi` has the exact same bytecode as `Class:privateHi`:\\r\\n```\\r\\n0000\\tFUNCF    4 \\r\\n0001\\tGGET     1   0      ; \\"print\\"\\r\\n0002\\tMOV      3   0\\r\\n0003\\tCALL     1   1   2\\r\\n0004\\tRET0     0   1\\r\\n```\\r\\nThe only difference is that one is inside a table, and one is a local.\\r\\n\\r\\n----------------------"},{"id":"versioning","metadata":{"permalink":"/blog/versioning","source":"@site/blog/2023-09-17_no_versioning.md","title":"UMG has no versioning","description":"In Untitled Mod Game, there is going to be no versioning of mods.","date":"2023-09-17T00:00:00.000Z","formattedDate":"September 17, 2023","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":5.235,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"versioning","title":"UMG has no versioning","tags":["design","umg"]},"prevItem":{"title":"Common lua idioms","permalink":"/blog/luaidioms"},"nextItem":{"title":"Why should I use an Entity Component System?","permalink":"/blog/ECS"}},"content":"In Untitled Mod Game, there is going to be no versioning of mods.<br/>\\r\\nThis is a very bold call, and it sounds stupid at face value.\\r\\nBut please, hear me out!<br/>\\r\\nThis lil article will explain my thought process.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n*(This article requires a basic understanding of my vision for Untitled Mod Game. If you are unfamiliar, [have a quick skim](../umgtech).)*\\r\\n\\r\\n---------------\\r\\n\\r\\nIn pretty much all software packaging systems, software has\\r\\nversion information.<br/>\\r\\nVersioning is great, because it allows introducing breaking changes to software without harming existing users.\\r\\n\\r\\nAnd that\'s pretty much the main \\"point\\" of versioning, is dealing with breaking changes. \\r\\nIf users don\'t want to deal with breaking changes, they can just stay on an older version.\\r\\n\\r\\nPros of versioning:\\r\\n- Allows developers to break compatibility in favour of better features or removal of tech debt\\r\\n- Users can use older versions if they want, granting a lot more freedom\\r\\n\\r\\nCons of versioning: (no major cons, really)\\r\\n- Userbase can become fragmented\\r\\n\\r\\n---------------\\r\\n\\r\\nNow, before we start, I\'d just like to note,\\r\\nI\'m **100% FOR** the use of versioning, and I think you\'d have to be an idiot not to see the value in it for 99% of situations.\\r\\n\\r\\nBut UMG is a bit special in what it\'s trying to achieve.<br/>\\r\\nThere\'s a very concerning situation where versioning could cause a bit of a mess, I\'ll explain it below.\\r\\n\\r\\n--------------------\\r\\n\\r\\nLet\'s do a thought experiment.<br/>\\r\\nLets assume that mods ARE versioned in UMG.\\r\\n\\r\\nAs discussed in [my other article](umgtech), a central goal of the UMG ecosystem is to ensure hyper-compatibility between mods.\\r\\n\\r\\nI want to be able to load the `ridable` mod, and have it work fully with the `projectiles` mod. That way, I can ride my horse off into the sunset, wielding my minigun, and rocking a cowboy hat.\\r\\n\\r\\nIdeally, the `projectiles` mod should not need to care about the `ridable` mod. In fact, both mods should not know about each other, since they are unrelated.<br/>\\r\\nHowever, both mods will still need to tag onto other mods.\\r\\nBoth the `projectiles` mod, and the `ridable` mod will need the `dimensions` mod to be loaded, so that they can fudge around with what dimensions steeds are in, and what dimensions projectiles are spawned in.\\r\\n\\r\\n```mermaid\\r\\nstateDiagram-v2\\r\\n    riding --\x3e dimensions_v0\\r\\n    projectiles --\x3e dimensions_v0\\r\\n```\\r\\n\\r\\nBut lets assume that there was a breaking change in the `dimensions` mod, from version 0.0 to version 1.0, which overhauled the way entities are stored inside of dimensions, and changed a few things about the API.\\r\\n\\r\\nLets say that the `riding` mod updated to the latest version, but the author of the `projectiles` mod disagreed with the changes, so they stayed on the older version.<br/>\\r\\nSuddenly, we would have a setup like so:\\r\\n\\r\\n```mermaid\\r\\nstateDiagram-v2\\r\\n    riding --\x3e dimensions_v1\\r\\n    projectiles --\x3e dimensions_v0\\r\\n```\\r\\n\\r\\nNow, what fricken SUCKS, is that `riding` and `projectiles` are no longer compatible.<br/>\\r\\nWhy? Because they use two different versions for the `dimensions` mod.\\r\\nWhen entites are emplaced into a world, their `.dimension` component is going to be handled (and mangled) by two competing systems; one in `dimensions_v1`, and one in `dimensions_v0`.<br/>\\r\\nThis is terrible.\\r\\n\\r\\nNow, one could argue that this \\"issue\\" is the fault of whoever wrote the dimensions mod.<br/>\\r\\nAnd I would 100% agree. But that\'s kinda ignoring the real issue here. The real issue, is that this setup, (where `riding` and `projectiles` use different versions) is ALLOWED to exist.\\r\\n\\r\\nThe `riding` mod works fine on it\'s own.<br/>\\r\\nThe `projectiles` mod works fine on it\'s own too!<br/>\\r\\n\\r\\nBut what\'s bad, is that this setup will spread like a cancer. Any mods that build on top of `riding` will no longer be able to use the `projectiles` mod. Same vice versa. We have created a situation where our beautiful degree of hyper-compatibility is killed.\\r\\n\\r\\nIt would have been much better if whoever wrote `projectiles` was instead forced to use `dimensions_v1`; that way, compatibility between mods is guaranteed.\\r\\n\\r\\n----------------\\r\\n\\r\\nTo hammer it home, here\'s a (simplified) version of the dependency tree for the existing UMG mod, `test`:\\r\\n\\r\\n\\r\\n```mermaid\\r\\n\\r\\nstateDiagram-v2\\r\\n    borders  --\x3e    dimensions\\r\\n    borders  --\x3e    rendering\\r\\n\\r\\n    base     --\x3e    typecheck\\r\\n\\r\\n    sync     --\x3e    reducers\\r\\n    base     --\x3e    objects\\r\\n    objects  --\x3e    typecheck\\r\\n    base     --\x3e    state_\\r\\n    state    --\x3e    objects\\r\\n    state    --\x3e    typecheck\\r\\n    state    --\x3e    reducers\\r\\n    base     --\x3e    input\\r\\n    input    --\x3e    objects\\r\\n    base     --\x3e    rendering\\r\\n    rendering        --\x3e    objects\\r\\n    rendering        --\x3e    typecheck\\r\\n\\r\\n    scheduling       --\x3e    typecheck\\r\\n    scheduling       --\x3e    objects\\r\\n    base     --\x3e    reducers\\r\\n    base     --\x3e    physics\\r\\n    physics  --\x3e    state_\\r\\n    physics  --\x3e    dimensions\\r\\n    physics  --\x3e    xy\\r\\n    xy       --\x3e    sync\\r\\n    xy       --\x3e    typecheck\\r\\n    xy       --\x3e    state_\\r\\n    xy       --\x3e    reducers\\r\\n    base     --\x3e    control\\r\\n    control  --\x3e    input\\r\\n    control  --\x3e    rendering\\r\\n    control  --\x3e    xy\\r\\n    control  --\x3e    sync\\r\\n    base     --\x3e    xy\\r\\n    base     --\x3e    follow\\r\\n    follow   --\x3e    control\\r\\n\\r\\n    juice    --\x3e    typecheck\\r\\n\\r\\n    base     --\x3e    initializers\\r\\n    initializers     --\x3e    dimensions\\r\\n    initializers     --\x3e    xy\\r\\n\\r\\n    ui       --\x3e    input\\r\\n    items    --\x3e    input\\r\\n\\r\\n    borders  --\x3e    objects\\r\\n    borders  --\x3e    typecheck\\r\\n    categories       --\x3e    base\\r\\n    categories       --\x3e    chunks\\r\\n    chunks   --\x3e    base\\r\\n    chat     --\x3e    base\\r\\n    commands         --\x3e    chat\\r\\n\\r\\n    crafting         --\x3e    base\\r\\n    crafting         --\x3e    items\\r\\n    grids    --\x3e    base\\r\\n    grids    --\x3e    categories\\r\\n    grids    --\x3e    typecheck\\r\\n\\r\\n    worldeditor      --\x3e    ui\\r\\n    worldeditor      --\x3e    chunks\\r\\n    modern   --\x3e    chunks\\r\\n    modern   --\x3e    chat\\r\\n    modern   --\x3e    ui\\r\\n    modern   --\x3e    grids\\r\\n    projectiles      --\x3e    mortality\\r\\n    projectiles      --\x3e    usables\\r\\n    test     --\x3e    base\\r\\n    test     --\x3e    juice\\r\\n\\r\\n    test     --\x3e    weather\\r\\n    weather  --\x3e    base\\r\\n    weather  --\x3e    light\\r\\n\\r\\n    test     --\x3e    borders\\r\\n\\r\\n    test --\x3e modern\\r\\n    test --\x3e projectiles\\r\\n\\r\\n```\\r\\n\\r\\nI simplified the diagram greatly, because the original was too cluttered and hard to read. (roughly half the edges have been omitted.)\\r\\n\\r\\nCan you *imagine* what a nightmare this would be, if every mod was able to use it\'s own versions for stuff?<br/>\\r\\nIt just wouldn\'t be possible. Versioning is not compatible with UMG\'s vision. \\r\\n\\r\\nBut as stated previously... versioning IS useful, mainly for dealing with breaking changes. So how does UMG deal with breaking changes?\\r\\n\\r\\nWell... it doesn\'t.<br/>\\r\\nBreaking changes will simply have to be avoided. To be fair, Java is a programming language [that has taken this exact approach](https://blog.jooq.org/the-lame-side-of-javas-backwards-compatibility/), and hey, they haven\'t done too poorly.\\r\\n\\r\\nThe main painstaking downside of this setup is that we are ASSUMING that the base mods are going to be developed in a forward thinking, robust manner.<br/>\\r\\nThat is, developed free of future tech debt, and developed with all future requirements predicted for, (an impossible task.)<br/>\\r\\nUnfortunetely, I don\'t believe there is another solution. C\'est la vie, brother!"},{"id":"ECS","metadata":{"permalink":"/blog/ECS","source":"@site/blog/2023-07-10_why_ecs.md","title":"Why should I use an Entity Component System?","description":"ECSes are really cool and fun! This article will explain why I love them so much.","date":"2023-07-10T00:00:00.000Z","formattedDate":"July 10, 2023","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"opinion","permalink":"/blog/tags/opinion"}],"readingTime":8.11,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"ECS","title":"Why should I use an Entity Component System?","tags":["design","opinion"]},"prevItem":{"title":"UMG has no versioning","permalink":"/blog/versioning"},"nextItem":{"title":"Technical implementation details for UMG","permalink":"/blog/umgtech"}},"content":"ECSes are really cool and fun! This article will explain why I love them so much.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nIf you drop an apple from an aeroplane, sooner or later, it will hit the ground,\\r\\nand no longer be an apple.<br/>\\r\\nAnd the same can be said about pears. And bananas. And most other objects,\\r\\nfor that matter.\\r\\n\\r\\nThe reason this happens is because of gravity.\\r\\nGravity is a rule that works on every object in the universe, which is how rules are supposed to work.\\r\\n\\r\\n-----------\\r\\n\\r\\n![apple_falling](images/apple_falling.jpg)\\r\\n\\r\\n------------\\r\\n\\r\\nIn software development, it seems like a lot of rules aren\'t programmed this way.\\r\\nWith the rise of OOP, programmers have been fixated on binding behaviour to objects,\\r\\ninstead of binding behaviour to the system itself.\\r\\n\\r\\nAnd in gamedev, this is something that has been challenged. (a lot.)\\r\\nClassic Entity Component System (ECS) architecture goes as far to say that no behaviour\\r\\nshould be bound to game entities at all; they should only have data, and systems (rules)\\r\\nshould then act on that data in a global fashion.\\r\\n\\r\\nTo sum it up from a gamedev perspective:<br/>\\r\\n- In classic OOP fashion, game entities contain functions. These functions define the behaviour of the entity.\\r\\n- In classic pure ECS architecture, game entities are not allowed to contain functions. Behaviour is instead defined by \\"systems\\", which are external scripts that act on entities.\\r\\n\\r\\n\\r\\nBut hang on... what even is a component? Or an entity, or a system?\\r\\n\\r\\n\\r\\nConcept\\t  | Explanation\\r\\n----------|-----------\\r\\nComponent |\\tPlain old data with a name. Like a position, or an image\\r\\nEntity    | A game object. E.g. an apple, truck, or human. Contains one or more components, grouped together. Does not contain code\\r\\nSystem\\t  | Code that processes all entities with certain components\\r\\n\\r\\n\\r\\n![ecs](images/ECS.png)\\r\\n\\r\\nTo better explain, I\'ll write a quick hacky example in pseudocode:\\r\\n\\r\\nEntities / components:\\r\\n```lua\\r\\n-- an entity containing x, y, image components\\r\\nlocal ent = {\\r\\n    x = 5, -- `x` component\\r\\n    y = 15, -- `y` component\\r\\n    image = \\"cat\\" -- `image` component\\r\\n}\\r\\n```\\r\\n\\r\\nSystems:\\r\\n```lua\\r\\n--[[\\r\\nThis is a view of entities that have all these components: (x, y, image)\\r\\n(We don\'t care what other components the entity may have.)\\r\\n]]\\r\\nlocal drawEntities = entityGroup<x, y, image>()\\r\\n\\r\\nfunction draw() {\\r\\n    -- called whenever we draw to screen\\r\\n    for ent in drawEntities {\\r\\n        draw(ent.image, ent.x, ent.y)\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n\\r\\nIn this example, we create a global rule.<br/>\\r\\nWe say: for all entities that have `x, y, image` components,\\r\\nwe will draw these entities to the screen.\\r\\n\\r\\nSimilar to how gravity is applied globally to all objects,\\r\\nwe are applying our draw rule globally to all entities that fit the profile.\\r\\n\\r\\nThis allows us to create much more natural rules, which can give way for some nice emergence.\\r\\n(I wrote [another blog post on emergence](../emergence), you should give it a read!)\\r\\n\\r\\nHowever, the biggest benefit to ECS is not actually the \\"naturalness\\" of it;\\r\\nrather, the biggest benefit is *scalability in design.*<br/>\\r\\nWe have applied a *global* rule to entities. And if you know anything about software\\r\\ndesign, alarm bells should be going off right now. Generally, global state and\\r\\nglobal behaviour is really bad, since it leaks out into the rest of the software and causes\\r\\na big mess.<br/>\\r\\nBut in this case, our global rule is not actually leaking anywhere.<br/>\\r\\nIt\'s entirely contained within the draw system. Isn\'t that beautiful?<br/>\\r\\nWhen we go write a new system, we don\'t need to care AT ALL about this global rule we made.\\r\\nThe only thing we need to care about are the components. But that\'s completely fine,\\r\\nbecause those entities were going to have those components anyway. Besides, there is no\\r\\nfunky behaviour tied up in the components; they are just data.\\r\\n\\r\\nIn fact, we can even create a new system, say, `AnimationSystem` that changes the `image` component\\r\\nwith respect to time to give entities an animation effect.\\r\\nWhat\'s beautiful, is that the `AnimationSystem` *does not need to care* about the draw system at all.\\r\\nThe systems are effectively communicating through components.\\r\\n\\r\\nAnd we don\'t stop there. We can keep scaling. We can keep adding as many systems, as many rules as we want,\\r\\nand none of the systems will ever need to interact with each other.\\r\\nAnd with every system we add, remember that the rules are applied *globally*.\\r\\n\\r\\nAnd that\'s what I find so amazing about this setup. Each system is just fudging with data.\\r\\nNo system needs to know more than neccessary; there are no monolithic systems that know too much,\\r\\nevery system only takes the bare minimum, and outputs the bare minimum.\\r\\nAnd we can afford to do the minimum, because our rules are applied globally; although are\\r\\nrules may not be doing much on their own, if we add all our rules together, we get a big complex\\r\\nsystem that is super easy to break down.\\r\\n\\r\\nAnd that\'s it! I probably ranted for too long here, but you get the idea.<br/>\\r\\nI see a lot of articles online praising ECS for it\'s cache performance benefits, and it\'s\\r\\nability to handle large swathes of entities. While this is true, I think what\'s more important is the\\r\\narchitectural side of it.\\r\\nIt allows us to handle massively complex systems whilst still being hyper-modular and hyper-generic.\\r\\n\\r\\n-----------------\\r\\n\\r\\nBefore I end this blog post, I want to discuss what I use for my project.\\r\\nBecause I don\'t exactly use a pure ECS as it stands, but most of my ideas have been\\r\\nadapted from the classic ECS setup:\\r\\n\\r\\n## What does UMG do?\\r\\n\\r\\nUntitled Mod Game is a project I\'ve been working on for a while.\\r\\nUMG uses a \\"special\\" ECS setup.<br/>\\r\\nI call it \\"special\\", because we break a few rules:\\r\\n\\r\\n**RuleBreak 1:** in UMG, entities are typed. (Classic ECS has no types for entities)<br/>\\r\\n**RuleBreak 2:** in UMG, entities can contain functions (OMG!!! EVIL!)<br/>\\r\\n\\r\\nTo visualize things, here is what an entity definition could look like in UMG:\\r\\n```lua\\r\\n-- a button entity that resets the board state when clicked\\r\\n\\r\\nlocal resetButton = {\\r\\n    image = \\"button1\\",\\r\\n\\r\\n    buttonPressAnimation = {\\r\\n        frames = {\\"button1\\", \\"button2\\", \\"button3\\"},\\r\\n        time = 0.5\\r\\n    },\\r\\n\\r\\n    buttonPressSound = \\"click\\"\\r\\n\\r\\n    onButtonPress = function(ent)\\r\\n        board:reset()\\r\\n    end\\r\\n}\\r\\n```\\r\\n\\r\\nSo, what\'s the reasoning behind breaking these two rules?\\r\\n\\r\\nRule 1 (entities having types) is broken partially for efficiency reasons.<br/>\\r\\nWith types, we can share static data across entities of the same type. \\r\\nIt also means that redundant data doesn\'t need to be sent over the network.\\r\\nAll in all, it\'s just a bit nicer.[^1]\\r\\n\\r\\n\\r\\nRule 2 (entities containing functions) is broken for practical reasons.<br/>\\r\\nIn my opinion, practicality is ALWAYS more important than ideology.\\r\\nSure, in theory, it makes sense for entities to never contain functions.<br/>\\r\\nBut what about really niche cases? For example, what if I want to make a gun that clones entities when shot?<br/>\\r\\nWell, let\'s try implement it!\\r\\n\\r\\nWe have a few options here:<br/>\\r\\n\\r\\n**OPTION 1:** Hardcode the clone gun behaviour inside a system that only the clone gun uses.  (Bad, because we are creating a global rule that will only affect one entity type)<br/>\\r\\n**OPTION 2:** Create a sophisticated command-template system. The clone gun can then use an on-hit clone command that\'s ran when the bullet hits an entity. (Better, but a blatant violation of YAGNI.)<br/>\\r\\n**OPTION 3:** Hardcode the clone gun behaviour inside a function within the clone gun entity. (Violation of pure ECS principles, but other than that, the easiest solution)\\r\\n\\r\\nOption 1 is obviously stupid, so lets just ignore it.\\r\\n\\r\\nLets look at what option 2 could look like:\\r\\n```lua\\r\\n-- clone gun entity:\\r\\nlocal cloneGun = {\\r\\n    gun = { bullets = 1, bulletSpeed = 200 },\\r\\n\\r\\n    bulletHitEffect = {\\r\\n        {effect = \\"clone\\", target = \\"target\\"}\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n-- But remember, we also need a system to intercept the bullet behaviour:\\r\\n-- bulletSystem.lua:\\r\\n\\r\\nlocal effects = {\\r\\n    ...\\r\\n}\\r\\nlocal targets = {\\r\\n    ...\\r\\n}\\r\\n\\r\\numg.on(\\"entityCollide\\", function(e1, e2)\\r\\n    if e1.bullet then \\r\\n        -- logic for applying the bullet hit effect here.\\r\\n        ... -- apply effect enum to target\\r\\n    end\\r\\nend)\\r\\n\\r\\n\\r\\n```\\r\\n\\r\\n\\r\\nAnd now, the 3rd option:\\r\\n```lua\\r\\n-- clone gun entity:\\r\\nlocal cloneGun = {\\r\\n    gun = { bullets = 1, bulletSpeed = 200 },\\r\\n\\r\\n    -- In this example, we put the cloning behaviour directly inside of the\\r\\n    -- clone gun entity.\\r\\n    -- This is a violation of ECS principles, because behaviour is supposed to be\\r\\n    -- applied globally...     but it gets the job done.\\r\\n    bulletHit = function(ent, bulletEnt, hitEnt)\\r\\n        hitEnt:deepClone()\\r\\n    end\\r\\n}\\r\\n```\\r\\n\\r\\nIn an ideal world, option 2 would be the best. \\r\\n\\r\\nBut the world is not ideal. Us programmers have limited time.<br/>\\r\\nAnd in the case of UMG, *modders* have limited patience.\\r\\nAre people really going to want to create a whole new system just to clone an entity?<br/>\\r\\nHell nah! People probably just want to see themselves clone their buddies as fast as possible.\\r\\n\\r\\nSo therefore, UMG allows functions inside of entities.\\r\\nNot because its good, but because I believe **practicality > ideology**.\\r\\n\\r\\nAnyway, that\'s it for this blog post.\\r\\n\\r\\nThanks for reading this opinion piece!\\r\\n\\r\\n- Oli\\r\\n\\r\\n\\r\\n\\r\\n[^1]: (Quick note: In most ECSes, entities having no types is due to entities being represented as a single integer. From there, component data is packed into big cache-friendly PoD arrays that systems can zoom over and transform super quickly. UMG is using lua, which doesn\'t have the cache optimization opportunities that most low level languages have. Hence, entities being explicit types is not harmful to performance since we can\'t optimize for cache misses anyway lol! I just wanted to emphasize this, because I made it sound like entities being untyped came from an architectural standpoint, whereas it\'s rather mainly from a performance standpoint.)"},{"id":"umgtech","metadata":{"permalink":"/blog/umgtech","source":"@site/blog/2023-06-2_umg_tech_details.md","title":"Technical implementation details for UMG","description":"----------------------------","date":"2023-06-02T00:00:00.000Z","formattedDate":"June 2, 2023","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"umg","permalink":"/blog/tags/umg"},{"label":"coding","permalink":"/blog/tags/coding"}],"readingTime":8.475,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"umgtech","title":"Technical implementation details for UMG","tags":["design","umg","coding"]},"prevItem":{"title":"Why should I use an Entity Component System?","permalink":"/blog/ECS"},"nextItem":{"title":"Question buses in UMG","permalink":"/blog/buses"}},"content":"\x3c!--truncate--\x3e\\r\\n\\r\\n----------------------------\\r\\n\\r\\n\\"Untitled Mod Game\\" (or \\"UMG\\" in short) is a multiplayer\\r\\ngame that is based on mods.\\r\\n\\r\\nI\'ve been developing it for many months at this point, and it\'s been really fun!\\r\\n\\r\\nIt\'s setup is similar to that of Garrys Mod,\\r\\nwhere most playable content is User-generated.\\r\\n\\r\\n------------------------------\\r\\n\\r\\nHowever, UMG seeks to take things a bit further, and address\\r\\na few issues that exist with the traditional traditional modding approach.\\r\\n\\r\\n**Traditional modding approach:**\\r\\n\\r\\n![traditional](images/regular_modding.png)\\r\\n\\r\\n-------------------\\r\\n\\r\\nWith UMG, we have two \\"types\\" of mods: \\"Base\\" and \\"Playable\\" mods.\\r\\n\\r\\n- Base mods:\\r\\n    - provide tools and infrastructure for modders to create content\\r\\n    - do not provide any playable content\\r\\n\\r\\n- Playable mods:\\r\\n    - provide gameplay and content\\r\\n\\r\\nWhat\'s interesting about this setup, is that there is no \\"game\\".\\r\\n*Everything* is built as a mod.<br/>\\r\\nHere\'s a diagram of what UMG would look like, under the same setup:\\r\\n\\r\\n![cooperative_modding](images/cooperative_modding.png)\\r\\n\\r\\n---------------\\r\\n\\r\\nBut, what\'s the point of this?<br/>\\r\\nHow is this any better than the former setup?<br/>\\r\\n\\r\\nTo explain the point of this, we need to understand what I call\\r\\n\\"The Riding problem\\".\\r\\n\\r\\n# The riding problem:\\r\\n\\r\\nLets imagine that we have 2 modders, \\"John\\" and \\"Mary\\".\\r\\n\\r\\nMary likes elephants, so she is making an elephant riding mod.\\r\\nJohn likes horses, so he is making a mod where you can ride horses.\\r\\n\\r\\nBoth Mary and John go about their business, and create their mods.\\r\\nSince there is no way for John and Mary to communicate, they both code\\r\\nthe riding behaviour independently.\\r\\n\\r\\nThis is *terrible*.<br/>\\r\\nWhy?  Well, the code for riding animals has been written twice independently.\\r\\nWhich is a big waste of time!\\r\\n\\r\\nIt would be much better if John and Mary\'s mods both \\"extended\\" a common mod,\\r\\ne.g, the \\"Ridable Animals Mod\\".\\r\\nThis way, code is only written once in a generic fashion, and time is saved.\\r\\n\\r\\nBut actually, there\'s a bigger problem than \\"duplicate code\\": *Compatibility.*<br/>\\r\\nImagine if someone loads the ridable elephants mod, and the ridable horses mod at the same time.<br/>\\r\\nImagine the player jumps on a horse, and then goes over to an elephant,\\r\\nand tries to ride the elephant *whilst riding* the horse.\\r\\n\\r\\nAt best, nothing happens.<br/>\\r\\nAt worst, the game crashes, or they get glitched across the world in an unpredictable fashion.\\r\\n\\r\\nWithout John and Mary following a standard protocol, there is no way for them\\r\\nto know if they are breaking each others work.\\r\\n\\r\\n-----------------------------\\r\\n\\r\\nIdeally, in UMG, the \\"ridable\\" behaviour would be extrapolated to a \\"Base\\" mod.\\r\\nThe \\"Playable\\" mods, (ridable horses and ridable elephants) could then extend the \\"ridable\\" mod.\\r\\n\\r\\n# Technical implementation:\\r\\nSo this setup is cool and all, but how would this work in a technical sense?<br/>\\r\\nHow do mods know about each other in this way?<br/>\\r\\nAlso, what stops other base mods from being incompatible with each other, causing the same class of problems?\\r\\n\\r\\nTo understand this, lets do a quick overview of UMG architecture:\\r\\n\\r\\n## The UMG Entity Component System:\\r\\n*If you have never heard of ECSes in a gamedev context, I recommend looking it up real quick.*\\r\\n\\r\\n\\r\\nIn UMG, everything in the world is an entity.\\r\\nPlayers, bullets, enemies, trees, grass, are all entities.<br/>\\r\\nEntities exist on both the server and the client; however only the server\\r\\nhas the authority to create and delete them.\\r\\n\\r\\nA `Group` is like an array that holds entities. (<-- Remember this, it\'s important.)<br/>\\r\\nEntities are automatically added to groups if they have the required components for that group.\\r\\n\\r\\n```lua\\r\\n-- Here\'s a group with components  .x, .y  .image  \\r\\n-- All entities with these components are added to myGroup automatically.\\r\\nlocal myGroup = umg.group(\\"x\\", \\"y\\", \\"image\\")\\r\\n```\\r\\n\\r\\nOur \\"Systems\\" then will iterate over `group`s of entities,\\r\\nexecuting code and changing the state of entities as they go.\\r\\n\\r\\nSo, back to the example from before. With the ridable horses and elephants.\\r\\nWith our setup, we could have both horses and elephants contain a `ridable`\\r\\ncomponent, and have a system act on all entities with `x, y, ridable` components.\\r\\n\\r\\n```lua\\r\\nlocal ridableGroup = umg.group(\\"ridable\\", \\"x\\", \\"y\\")\\r\\n\\r\\nlocal function update()\\r\\n    for ent in ridableGroup do\\r\\n        local riderEnt = ent.rider\\r\\n        if riderEnt ~= nil then\\r\\n            -- set the rider\'s position to the steed ent.\\r\\n            riderEnt.x = ent.x\\r\\n            riderEnt.y = ent.y\\r\\n            riderEnt.z = ent.z + ent.ridable.rideHeight\\r\\n        end\\r\\n    end\\r\\nend\\r\\n\\r\\n-- Code for mounting.  This can be called by other mods, and is\\r\\n-- called automatically when the player clicks on the steed.\\r\\nlocal function mount(steedEnt, riderEnt)\\r\\n    if not ridableGroup:has(steedEnt) then\\r\\n        error(\\"this entity isn\'t ridable!\\")\\r\\n    end\\r\\n    steedEnt.rider = riderEnt\\r\\nend\\r\\n\\r\\n... -- more code here, etc\\r\\n```\\r\\n\\r\\nI\'d also like to point out that `riderEnt` does not neccessarily have to be a player.\\r\\nIn UMG, there\'s not really such thing as a \\"player\\"; a player is just a regular entity.<br/>\\r\\nWith this generic setup, we can have any entity type doing the riding. Which allows cool stuff such as:\\r\\n- Enemies on horses\\r\\n- Horses with chests on their back (chest entity is riding)\\r\\n- Horses with lights on their back (torch entity is riding)\\r\\n- Elephants with gun turrets on their back (turret entity is riding)\\r\\n\\r\\nBut anyway, that\'s getting sidetracked.<br/>\\r\\nThe main point of this is that now both the horse and the elephant can follow a\\r\\nstandard protocol for riding:\\r\\n```lua\\r\\n-- Horse entity\\r\\nreturn {\\r\\n  image = \\"horse\\",\\r\\n  ridable = {\\r\\n    rideHeight = 10\\r\\n  },\\r\\n  speed = 45\\r\\n}\\r\\n```\\r\\n\\r\\n```lua\\r\\n-- Elephant entity\\r\\nreturn {\\r\\n  image = \\"elephant\\",\\r\\n  ridable = {\\r\\n    rideHeight = 28\\r\\n  },\\r\\n  speed = 10\\r\\n}\\r\\n```\\r\\n\\r\\nAwesome!  Now, John and Mary\'s mods work together just fine. \\r\\n\\r\\n-------------\\r\\n\\r\\nUnfortunetely, Mary and John still have some problems that need to be addressed.\\r\\n\\r\\nIn John\'s horse riding mod, he wants to limit horse riding to the \\"knight\\" class.<br/>\\r\\nIn Mary\'s elephant riding mod, she wants the elephants to flap their ears when the player mounts.\\r\\n\\r\\nBut... how can this be solved?<br/>\\r\\nRemember, the `riding` mod is a *base mod.*\\r\\nWhich means it knows NOTHING about the current game context; all it cares about is the `ridable` component.\\r\\n\\r\\nSo, the `riding` mod knows NOTHING about elephant ears.<br/>\\r\\nIt also knows NOTHING about \\"knights\\" either. The concept of \\"knights\\" may not even exist, depending on what mods are loaded!\\r\\n\\r\\n## Mod communication through event buses:\\r\\n\\r\\nTo give Mary and John the tools to solve this problem, we can use [event-buses and question-buses.](../buses)\\r\\n\\r\\nSpecifically, John and Mary need two things:\\r\\n- Mary needs an event to be emitted whenever a ridable entity is mounted\\r\\n- John needs to signal to the `riding` mod that horses can\'t be mounted unless the entity is of knight class\\r\\n\\r\\nSo, lets update our `mount` function from before:\\r\\n```lua\\r\\n\\r\\nlocal function mount(steedEnt, riderEnt)\\r\\n    if not ridableGroup:has(steedEnt) then\\r\\n        error(\\"this entity isn\'t ridable!\\")\\r\\n    end\\r\\n\\r\\n    -- John needs to answer this question\\r\\n    if umg.ask(\\"ridingNotAllowed\\", OR, steedEnt, riderEnt) then\\r\\n        return -- not allowed!\\r\\n    end\\r\\n    \\r\\n    -- Mary needs this event\\r\\n    umg.call(\\"entityMounted\\", steedEnt, riderEnt)\\r\\n    steedEnt.rider = riderEnt\\r\\nend\\r\\n\\r\\n```\\r\\n\\r\\nNow, John and Mary can tag into these events, like so:\\r\\n```lua\\r\\n-- John\'s code:\\r\\numg.answer(\\"ridingNotAllowed\\", function(steedEnt, riderEnt)\\r\\n    if steedEnt.animalType == HORSE and riderEnt.class ~= KNIGHT then\\r\\n        return true\\r\\n    end\\r\\n    return false\\r\\nend)\\r\\n```\\r\\n\\r\\n```lua\\r\\n-- Mary\'s code:\\r\\numg.on(\\"entityMounted\\", function(steedEnt, riderEnt)\\r\\n    if steedEnt.animalType == ELEPHANT then\\r\\n        flapElephantEars(steedEnt)\\r\\n    end\\r\\nend)\\r\\n```\\r\\n\\r\\nVoila! Now, Mary and John can both have what they want, and\\r\\n*what\'s best*, is that their code is still 100% compatible.<br/>\\r\\nIsn\'t that beautiful?\\r\\n\\r\\nThis idea where mods are forced to be hyper-generic and hyper-compatible is a central goal of the UMG ecosystem.\\r\\n\\r\\nOther mods may also tag onto this stuff, and it will be 100% fine,\\r\\nsince the `ridable` mod doesn\'t care (and doesn\'t even know) what mods are listening\\r\\nto the events and answering the questions.\\r\\n\\r\\nFor example, maybe we want to have two teams, RED and BLUE.<br/>\\r\\nThis code makes it so only Blue team can use Blue horses, and same for Red:\\r\\n```lua\\r\\n-- Team system\\r\\numg.answer(\\"ridingNotAllowed\\", function(steedEnt, riderEnt)\\r\\n    if steedEnt.team and riderEnt.team and (steedEnt.team ~= riderEnt.team) then\\r\\n        -- not in same team! disallow riding.\\r\\n        return true\\r\\n    end\\r\\n    -- entities are either in same team, or don\'t have a team.\\r\\n    return false \\r\\nend)\\r\\n```\\r\\n\\r\\nWhat\'s great, is that this code is 100% compatible with John and Mary\'s code from before.\\r\\nIt\'s just *beautiful*.\\r\\n\\r\\n\\r\\n# Mod communication through components:\\r\\n\\r\\nEvents buses are not the only way mods can communicate.<br/>\\r\\nOften, communication is done by simply changing component values from within entities.\\r\\n\\r\\nHere\'s an example:\\r\\n\\r\\n--------------------\\r\\n\\r\\nLets say we want our mod to render entities:\\r\\n```lua\\r\\n-- rendering system\\r\\nlocal drawGroup = umg.group(\\"image\\", \\"x\\", \\"y\\")\\r\\n\\r\\nlocal function draw()\\r\\n    -- this draw function is called every frame\\r\\n    for ent in drawGroup do\\r\\n        graphics.draw(ent.image, ent.x, ent.y)\\r\\n    end\\r\\nend\\r\\n```\\r\\nIn this base mod, anything with an image, x, and y will be drawn to the screen.\\r\\n\\r\\nTo use this functionality, we can simply add the `x, y, image` components to one of our entities:\\r\\n```lua\\r\\nlocal ent = newEntity()\\r\\n\\r\\nent.x = 10\\r\\nent.y = 15\\r\\nent.image = \\"banana\\"\\r\\n```\\r\\nNow, this entity will be drawn to the screen automatically, at position (10, 15), with image \\"banana\\".\\r\\n\\r\\nAwesome!<br/>\\r\\nOkay, but what if we want an animation?\\r\\n\\r\\nTo handle animation, we can have another system that *changes* the `.image` component\\r\\nwith respect to time.<br/>\\r\\nFor example:\\r\\n```lua\\r\\n-- animation system\\r\\nlocal animationGroup = umg.group(\\"animation\\")\\r\\n\\r\\nlocal function update()\\r\\n    -- this function is called every frame\\r\\n    local time = getTime()\\r\\n    for ent in animationGroup do\\r\\n        ent.image = getAnimationImage(ent.animation, time)\\r\\n    end\\r\\nend\\r\\n```\\r\\n\\r\\nWhat\'s cool, is that this animation code and the rendering code from before\\r\\ncan be in entirely different systems, or even in *entirely different mods.*\\r\\n\\r\\nHere, the `animation` system is assuming that the rendering code will handle\\r\\nthe drawing of the entity, so all that it needs to care about is setting the image.\\r\\n\\r\\nIt\'s beautiful, right? :)\\r\\n\\r\\n\\r\\n# To conclude:\\r\\n\\r\\nThis document gives a brief overview of some design challenges (and solutions) that the UMG ecosystem has to deal with.\\r\\n\\r\\nI hope that the whole Base-mod / Playable-mod setup is a lot clearer, and I hope the\\r\\nreasoning behind it makes sense now.<br/>\\r\\nIt\'s certainly a challenging and interesting project, and I absolutely wish to see it through.\\r\\n\\r\\nThanks for reading.\\r\\n- Oli"},{"id":"buses","metadata":{"permalink":"/blog/buses","source":"@site/blog/2023-05-10_question_buses.md","title":"Question buses in UMG","description":"Question buses are a cool idea! This article will explain what they are.","date":"2023-05-10T00:00:00.000Z","formattedDate":"May 10, 2023","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":5.025,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"buses","title":"Question buses in UMG","tags":["design","umg"]},"prevItem":{"title":"Technical implementation details for UMG","permalink":"/blog/umgtech"},"nextItem":{"title":"Emergence in games","permalink":"/blog/emergence"}},"content":"Question buses are a cool idea! This article will explain what they are.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n-------------------\\r\\n## PRELUDE: \\r\\n*This reading requires a basic understanding of my vision for Untitled Mod Game:*<br/>\\r\\nAll you need to know is that there are two types of mods, \\"Base mods\\",\\r\\nand \\"Playable mods.\\"\\r\\n\\r\\n- Base mods:\\r\\n    - provide tools and infrastructure for modders to create content\\r\\n    - do not provide any playable content\\r\\n\\r\\n- Playable mods:\\r\\n    - provide gameplay and content\\r\\n----------------------\\r\\n\\r\\n\\r\\n# Before we look at question buses, lets understand event buses.\\r\\n\\r\\nEvent bus diagram:\\r\\n\\r\\n![event_bus](images/event_bus.png)\\r\\n\\r\\nEvent buses are an *awesome* tool in the context of Untitled Mod Game.\\r\\n\\r\\nWhenever a significant action happens in a base mod, that base mod can simply\\r\\nemit an event to tell other mods that something interesting happened.\\r\\n\\r\\nWhat\'s beautiful, is that the base mod emitting the event doesn\'t care who\'s listening.\\r\\nIt just throws the event into the void; the systems that care about it will\\r\\ntag into it. Perhaps no one is listening! Perhaps 10 other mods are listening.\\r\\nThe base mod doesn\'t care.\\r\\n\\r\\nA good example of this is the `entityDeath` event.<br/>\\r\\nThis event is called automatically when an entity dies, and the entity is\\r\\npassed in as the first argument, like so:\\r\\n```lua\\r\\n-- base mod\\r\\numg.call(\\"entityDeath\\", ent)\\r\\n```\\r\\nIf other systems want to listen to this event, they can use `umg.on`:\\r\\n```lua\\r\\n-- Meanwhile, in a completely different mod:\\r\\numg.on(\\"entityDeath\\", function(ent)\\r\\n    -- plays a death sound when an entity dies.\\r\\n    if ent.deathSound then\\r\\n        playSound(ent.deathSound)\\r\\n    end\\r\\nend)\\r\\n```\\r\\n\\r\\nNow, this stuff is pretty basic, and this is nothing new. Event buses are a common\\r\\npattern, especially in game development.\\r\\n\\r\\nI could give examples of the entity emitting blood particles if it has the `meat` component,\\r\\nor spawning a full-health copy of itself if it has the `secondLife` component, but that\'s not the point\\r\\nof this post.\\r\\n\\r\\n\\r\\n# The problem space:\\r\\n\\r\\nOkay, so event buses are great for dispatching information when we are within an unknown context.\\r\\n\\r\\nBut sometimes we don\'t want to dispatch information.<br/>\\r\\nInstead, we may want to *receive* information.\\r\\n\\r\\nBehold, the holy *question bus*!!\\r\\n\\r\\n(I think it\'s best explained if I give a problem statement, and an example.)\\r\\n\\r\\nLets imagine that we have a system for attacking entities.<br/>\\r\\nThis system needs to know if an entity can attack or not.<br/>\\r\\nBut it doesn\'t know what other mods are loaded! It also doesn\'t know the context of the game\\r\\noutside of it\'s pure little abstract layer.\\r\\n\\r\\nSo, we turn to *question buses.*\\r\\n\\r\\n-----------------------\\r\\n\\r\\nWith question buses, we have two functions: \\r\\n```lua\\r\\n-- asks a question\\r\\numg.ask(question, reducer, ...)\\r\\n\\r\\n-- answers a question\\r\\numg.answer(question, answerFunc)\\r\\n```\\r\\n\\r\\n\\r\\n`ask` is similar to `call`, in that it initiates the \\"interaction\\".\\r\\n```lua\\r\\n-- attack system\\r\\nlocal reducer = operators.OR\\r\\n\\r\\nlocal isAttackBlocked = umg.ask(\\"isAttackBlocked\\", reducer, entity, targetEntity)\\r\\n```\\r\\n`reducer` is the reducer function; it reduces all the answers to one value\\r\\nby repeatedly applying itself to the answers.<br/>\\r\\n(By nature, the reducer needs to be associative and commutative,\\r\\nSo functions like `SUM` or `AND` would also work.)\\r\\n\\r\\n------------------------\\r\\n\\r\\n`answer` is similar to `on`, in that it responds to a question.<br/>\\r\\nInstead of executing something, however, the `answer` should ideally be a pure\\r\\nfunction that just returns a result. For example:\\r\\n```lua\\r\\n-- team handler system\\r\\n\\r\\numg.answer(\\"isAttackBlocked\\", function(entity, targetEntity)\\r\\n    if entity.team == targetEntity.team then\\r\\n        -- the entities are in the same team, so the attack should be blocked.\\r\\n        return true\\r\\n    end\\r\\n    return false\\r\\nend)\\r\\n```\\r\\n\\r\\nWe may also have another answer, e.g. inside the stun system:\\r\\n```lua\\r\\numg.answer(\\"isAttackBlocked\\", function(entity, targetEntity)\\r\\n    if entity.stunned then\\r\\n        -- entity is stunned, and cannot attack\\r\\n        return true \\r\\n    end\\r\\n    return false\\r\\nend)\\r\\n```\\r\\n\\r\\nIf either of these \\"answerers\\" return true, then the attack is blocked.\\r\\n\\r\\n-----------------\\r\\n\\r\\nHere\'s an image that hopefully clarifies the idea further:\\r\\n\\r\\n![question_bus](images/question_bus.png)\\r\\n\\r\\n-----------------\\r\\n\\r\\nAll in all, the pattern can be summarized simply as so:\\r\\n\\r\\n- Regular event buses:\\r\\n    - Dispatch information in an abstract manner\\r\\n    - Doesn\'t care who is listening\\r\\n\\r\\n- Question buses:\\r\\n    - Gather information in an abstract manner\\r\\n    - Doesn\'t care who gives the information\\r\\n\\r\\n------------------\\r\\n\\r\\nNow, just quickly, I want to recap on why this pattern is actually useful.\\r\\n*Why wouldn\'t you just check if the entities are on the same team in the `attack` code, instead of asking?*\\r\\n\\r\\nWith this setup, the `attack` system doesn\'t *know* about the concept of teams.\\r\\nIn fact, the concept of \\"teams\\" may not even exist, depending on what mods are loaded!\\r\\n\\r\\nThe attack system is asking a question in an abstract manner, and getting different results\\r\\ndepending on the what mods are loaded.\\r\\n\\r\\nThis is the exact same thing as event buses, except we are receiving information instead\\r\\nof dispatching information.\\r\\n\\r\\n# Is this pattern useful enough to justify it\'s existance?\\r\\n\\r\\nIt\'s pretty obvious just from looking at this pattern to see how easily\\r\\nit could be abused.<br/>\\r\\nIt\'s the same as normal event buses; powerful, yet easy to abuse.\\r\\n\\r\\nSo, given the abuse potential, is this pattern worth it?\\r\\n\\r\\n**Yes**, I would say so.<br/>\\r\\nPerhaps this pattern is not useful in other problem spaces, but in UMG where we\\r\\nliterally **NEED** a way to receive information unassumingly, question buses just... *chefs kiss.*\\r\\n\\r\\nTo demonstrate why, here are some other questions that could be asked:\\r\\n```lua\\r\\numg.ask(\\"canOpenInventory\\", OR, inventory, ent) -- whether an inventory can be opened by `ent`\\r\\numg.ask(\\"isHidden\\", OR, ent) -- whether `ent` is hidden\\r\\numg.ask(\\"canUseItem\\", OR ent, itemEnt) -- whether `ent` can use `itemEnt`\\r\\numg.ask(\\"canRide\\", OR, ent, steedEnt) -- whether `ent` can ride `steedEnt`\\r\\n\\r\\n-- a more interesting one:\\r\\numg.ask(\\"getDamageMultiplier\\", MULTIPLICATION, ent, targetEnt)\\r\\n-- returns the damage multiplier for `ent`.\\r\\n-- Note that the reducer function is multiplication in this case.\\r\\n-- This is because we are combining the damage multipliers from all answers.\\r\\n```\\r\\n\\r\\n\\r\\n# To conclude:\\r\\nquestion buses are a cool concept! :)\\r\\n\\r\\nAlthough they can probably be abused very easily, (same as event buses,)\\r\\nthey still provide a very useful pattern for my project.\\r\\n\\r\\nThanks for reading this opinion piece! I hope I opened your mind a bit.\\r\\n\\r\\n- Oli"},{"id":"emergence","metadata":{"permalink":"/blog/emergence","source":"@site/blog/2023-04-28_emergence.md","title":"Emergence in games","description":"Emergence is not needed for a good game. And we know this, because there are","date":"2023-04-28T00:00:00.000Z","formattedDate":"April 28, 2023","tags":[{"label":"gamedesign","permalink":"/blog/tags/gamedesign"},{"label":"opinion","permalink":"/blog/tags/opinion"}],"readingTime":14.235,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"emergence","title":"Emergence in games","tags":["gamedesign","opinion"]},"prevItem":{"title":"Question buses in UMG","permalink":"/blog/buses"}},"content":"Emergence is not needed for a good game. And we know this, because there are\\r\\nplenty of successful games out there that are non-emergent. \\r\\n(Some examples being: Super Meat Boy, the whole Call of Duty franchise, Mario Kart)\\r\\n\\r\\nBut as an indie developer, we are in a field where we **NEED** to put ourselves ahead by taking risks.\\r\\nIf we don\'t, we will be outcompeted by others similar to us.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nEmergence offers us a way to create way more gameplay opportunities, for very little cost.\\r\\nAs an indie dev, creating extra gameplay without needing to expend vast amounts of resources\\r\\nis very useful.\\r\\n\\r\\nBut... what *IS* Emergence in a game context?<br/>\\r\\nEmergence itself is quite hard to define! \\r\\n\\r\\nSo in this blog post, I\'ll examine a few examples of good emergence from existing games,\\r\\nand cherry pick what I think is the good stuff.\\r\\n\\r\\nKeep in mind, this is all just my opinion!\\r\\n\\r\\nBefore we dive into it, though; we need to do some housekeeping.\\r\\n\\r\\n--------------------------\\r\\n\\r\\n## Lets discuss the golden rule:\\r\\nChess is a highly-emergent game.<br/>\\r\\nBecause of this, it has existed for thousands of years, and is one of the most popular\\r\\ngames played by people to this date.\\r\\n\\r\\n![chess](images/chess.jpg)\\r\\n\\r\\nBut chess on its own is not very interesting.<br/>\\r\\nImagine if you were playing 1-player chess, where you just moved the pieces around.\\r\\nWould that be very fun? (No, it\'s not fun. And I know it\'s not fun, because nobody does it.)<br/>\\r\\nI\'m using this example, because I want to clarify something important, which I call\\r\\n\\"The golden rule\\":\\r\\n\\r\\n- *Emergence on its own won\'t cut it. You need Emergence, combined with the human mind.*\\r\\n\\r\\nSuddenly, if you have another player on the other side of the board,\\r\\nplotting their moves, and attempting to discover your tactics,\\r\\nyou have a very interesting and complex game.\\r\\n\\r\\nTo put it elegantly, emergence in games is not about creating \\"cooler\\" or \\"better\\" rules;\\r\\nrather, it\'s about allowing the player to create their own gameplay THROUGH the rules.[^1]\\r\\n\\r\\nWhen chess was first created, I can almost guarantee that the Fried-Liver attack did not exist.\\r\\nHumans created this gameplay element, *using* the emergent ruleset of chess.\\r\\n\\r\\n--------------------------\\r\\n\\r\\nNow, chess is a simple example that\'s easy to grasp, but also a very basic, and awkward example.\\r\\nSince a lot of the gameplay is not actually created by the player, but rather, by the opponent.\\r\\n\\r\\nSo lets look at another game that allows its players to create gameplay value, \\r\\nwithout the need for an opponent:\\r\\n\\r\\n## *Minecraft.*\\r\\n\\r\\nMinecraft is a ground-breaking, brilliant game.\\r\\nBefore minecraft, there was no real sandbox game available to the casual gamer.\\r\\n\\r\\nIt was so ahead of its time, and its success kinda speaks for itself.\\r\\n\\r\\nWhat I\'d like to look at though, is its emergent game rules.\\r\\nNow, there are 2 distinct examples that I want to pick apart here;\\r\\nlets not get lost in the weeds though. The two distinct examples are:\\r\\n\\r\\n- Emergence in building\\r\\n- Emergence in engineering\\r\\n\\r\\n## Minecraft- Emergence in building:\\r\\nIn minecraft, many players just want to build cool shit.\\r\\nI\'d argue that *most* players want to do this, actually.\\r\\n\\r\\n- Take a look at this image:\\r\\n\\r\\n![minecraft](images/minecraft.jpg)\\r\\n\\r\\nTo a minecraft player, this will look quite normal.\\r\\nIt\'s a little cottage, with a cute little wooden roof and windows. <br/>\\r\\nOn the right are some nice stair blocks leading to a deck.\\r\\n\\r\\nBut lets slow down a bit; take a look at the sloped roof.\\r\\nOn the roof of the house are ALSO stair blocks, lined up to produce a nice slope.\\r\\n\\r\\nIn Minecraft, the same blocks can be used in different ways to allow the builder \\r\\nto express their creativity to a higher degree.\\r\\n\\r\\nLook again, at the windows, and the door. Stairs are being used AGAIN,\\r\\nthis time, to provide some depth to the walls, and to provide a rounded entrance.\\r\\nRemember: stairs are just one block type. Players only need to remember one recipe to\\r\\ncreate all this wonderful stuff. Isn\'t that brilliant? \\r\\n\\r\\nOne block on its own does not do anything interesting, but multiple blocks\\r\\ntogether, *combined* with the human mind, allows the player to create gameplay\\r\\nopportunities for themselves.[^1]\\r\\n\\r\\n\\r\\n## Minecraft- Emergence in engineering:\\r\\n\\r\\nThis is a more interesting aspect, but it also gives way to a more important concept that I\\r\\nwant to talk about: ***Simplicity.***\\r\\n\\r\\nIf you are a minecraft player, you have probably seen those videos of huge industrial\\r\\nmob farms that automatically farm resources for you.\\r\\n\\r\\n(If you haven\'t, quickly google \\"efficient iron farm\\" on youtube, you\'ll see a bunch of unique designs)\\r\\n\\r\\nFor a second though, lets stop to ponder. Did the developers of minecraft intend for there\\r\\nto be massive, industrial item-farms?\\r\\nMaybe! But whatever the case, they *definitely* did not conceive the designs.\\r\\n\\r\\nI\'ll run briefly how a basic mob-farm may work, by breaking down the systems:\\r\\n- Water pushes entities in its flow direction\\r\\n- Mob entities spawn in the dark\\r\\n- Mob entities drop item entities on death\\r\\n- Entities with health take damage if they fall a big distance\\r\\n\\r\\nWith these rules, players can create a chamber that automatically spawns mobs,\\r\\npushes them to a cliff, kills the mobs, and transports the dropped items to a safe collection point.\\r\\n\\r\\n(Also note that these rules are all independent of one another.\\r\\nAny one of these rules may be used in another context independently to produce gameplay.)\\r\\n\\r\\nThese farms are not created because the minecraft devs wanted you to create them.\\r\\nThey are created because the players have a goal: \\"Get resources\\".\\r\\nAnd with this goal, the players can bend the world to their will, because the rules are emergent enough\\r\\nto allow it.\\r\\n\\r\\nBut, we are missing something important. The vast majority of players won\'t build these giant,\\r\\ncomplex, intricately engineered item farms.\\r\\n\\r\\nWhy not?\\r\\n\\r\\nIn my opinion, it all comes down to *simplicity.*<br/>\\r\\nIf the rules become too difficult to apply in a creative manner, then\\r\\na bunch of players are cut off. (either because they aren\'t patient enough, or they aren\'t willing\\r\\nto invest a lot of mental energy in the game.)\\r\\nThese massive, industrial farms are not simple to make; they require quite a deep understanding\\r\\nof the game systems, and they definitely require a lot of human creativity.\\r\\n\\r\\nRemember the golden rule: \\r\\n- *Emergence on its own won\'t cut it. You need Emergence, combined with the human mind.*\\r\\n\\r\\nPlayers that aren\'t engaged enough to invest a bunch of time and energy\\r\\nwill fail to create these gameplay opportunities.[^1]\\r\\n\\r\\nTo sum it up, it\'s not about how *simple* the rules are; rather, it\'s about how\\r\\n*simply the player can work with them.*\\r\\n\\r\\n\\r\\n## Is Minecraft cheating?\\r\\n\\r\\nOkay, we get it. Minecraft is a brilliant game.<br/> \\r\\nAnd its success shows it.\\r\\n\\r\\nBut doesn\'t it cheat? Minecraft is a sandbox game; of course its going to be highly emergent\\r\\nwhen the player can literally alter the world.\\r\\n\\r\\nYes, that\'s true; sandbox games *are* naturally emergent.\\r\\nBut Minecraft still does it the best, IMO.<br/>\\r\\nThere are many minecraft-like games that have been no-where near as successful,\\r\\nbecause they don\'t provide the player with emergent gameplay opportunities like minecraft does.\\r\\n\\r\\nA few examples of this are:\\r\\n- Eden\\r\\n- Trove\\r\\n- Eco\\r\\n\\r\\nI\'ve hardly been able to find any \\"automatic farm\\" designs for any of these games;\\r\\n(Or at least, no designs that are out of scope of what the developer intended.)\\r\\n\\r\\nPretty much all existing designs for stuff lay within the developer\'s closed vision for gameplay,\\r\\nwhich is a sign of insufficient emergence.\\r\\n\\r\\n-------------\\r\\n\\r\\nOkay, cool.\\r\\n\\r\\nSo what\'s an example of emergent gameplay that\'s NOT within a sandbox context?\\r\\n\\r\\n## Emergence in the Binding of Isaac\\r\\n\\r\\n![isaac](images/isaac.jpg)\\r\\n\\r\\nYup yup, it\'s this game.\\r\\nIf you play roguelikes, you probably saw this from a mile away.\\r\\n\\r\\nThe Binding of Isaac has seen years and years of praise, and is (arguably) the\\r\\nmost successful indie roguelike ever.\\r\\n\\r\\nBut to understand what makes Isaac fun, we need quickly understand the core game:\\r\\n\\r\\n- Player starts a run with randomly generated levels\\r\\n- Player fights her way through levels, achieving upgrades and items\\r\\n- Player either dies, or beats the game in less than 40 minutes\\r\\n- (Repeat, ad infinitum)\\r\\n\\r\\nA lot of the \\"fun\\" in Isaac comes from the player\'s ability to obtain synergies\\r\\nbetween items, and make an interesting/powerful combo.\\r\\n\\r\\nBut how are synergies done? There are hundreds (if not thousands) of roguelikes on the\\r\\nmarket that have synergies between items.<br/>\\r\\nWhat does Isaac do that\'s special?\\r\\n\\r\\n-------------\\r\\n\\r\\nLets create two imaginary items, `Item X` and `Item Y`.\\r\\n\\r\\nNow lets assume that items X, Y apply some effect to the player.\\r\\nIn this example, it doesn\'t matter too much what they actually do;\\r\\njust know that they do *something*.\\r\\n\\r\\nAs a game designer, we might want to add a synergy between `X` and `Y`.\\r\\nSo, lets hardcode a little rule:\\r\\n```c\\r\\nItem X synergizes with Item Y, by granting 10 attack damage\\r\\n```\\r\\n\\r\\nBut this is terrible.<br/>\\r\\nWhy? Why is this terrible?\\r\\n\\r\\nThis is terrible, because it\'s a very closed, non-emergent ruleset.<br/>\\r\\nIf another item comes along, (i.e. `Item Z`) it will never be able to mesh\\r\\ncreatively with the existing synergy between `X` and `Y`.\\r\\n\\r\\nIt would be much better to have a system that tags into mechanics instead.\\r\\nLets imagine we have a game mechanic \\"M\\".\\r\\nOur setup could look like:\\r\\n```c\\r\\nItem X: provides \\"M\\"\\r\\nItem Y: adds attack damage equal to \\"M\\"\\r\\n```\\r\\n\\r\\nSuddenly, we have a more interesting ruleset on our hands, that provides\\r\\nthe *exact same* synergy.\\r\\n\\r\\n*Why is this better, though?*<br/>\\r\\nWell, if we create another item, `Item Z`, we can mesh `Z` with the existing\\r\\nmechanic `M`:\\r\\n```c\\r\\nItem Z: doubles \\"M\\" when the player is on low health.\\r\\n```\\r\\n\\r\\nSuddenly, we have potential for a synergy between `Item Z`, and `Item Y` for free. Isn\'t that brilliant?<br/>\\r\\nIt cost us *NOTHING* to do this, we literally gained gameplay for free.<br/>\\r\\nNot only this, but any other item that meshes with the existing mechanic \\"M\\" will either be a synergy/anti-synergy to `Item Z` and `Item Y`.\\r\\n\\r\\nThe Binding of Isaac does this kind of thing really *really* well,\\r\\nby having virtually all passive items tag into game mechanics and mesh with\\r\\nother items by proxy.\\r\\n\\r\\nHere are some examples.<br/>\\r\\nI have listed the mechanic (`M`) that it tags into, too.\\r\\n\\r\\n```\\r\\n- Host hat: immune to explosion damage\\r\\n- Kamikaze: creates a damaging explosion next to the player\\r\\n- Glitter bombs: Your explosions spawn pickups\\r\\n- MECHANIC: Explosions\\r\\n```\\r\\nThis synergy gives infinite pickups, free explosions, and a tonne of damage.\\r\\n\\r\\n```\\r\\n- Brimstone:  Replaces tears with a slow, massive damaging lazer beam\\r\\n- Tammys head:  releases a burst of whatever tear type is active\\r\\n- MECHANIC: Fire rate / tear type\\r\\n```\\r\\n\\r\\n```\\r\\n- Lump of coal:  Shots deal extra damage based on distance travelled\\r\\n- Tiny planet:  Shots orbit, travelling for way longer\\r\\n- MECHANIC: Shot range / shot trajectory\\r\\n```\\r\\n\\r\\nEach of these examples provides a cool synergy that is good for the player.\\r\\n\\r\\nWhat\'s important, is that none of these items directly interact with each other.\\r\\nRather, the items mesh with *an existing mechanic*;\\r\\na mechanic that may affect (or be affected) by any other item in the game.\\r\\n\\r\\n\\r\\n## Emergence as a natural phenomenon\\r\\n\\r\\nSometimes, instead of programming game rules directly, it might be best\\r\\nto work backwards.\\r\\n\\r\\nTake a mental note of the intended behaviour,\\r\\nand develop natural rules to produce that behaviour in the game.\\r\\n\\r\\nFor example, instead of doing this:\\r\\n```\\r\\nwhen bullet entity collides ---\x3e deal damage\\r\\n```\\r\\n\\r\\nYou could do this:\\r\\n```\\r\\nFast moving, sharp entities ---\x3e Deal damage\\r\\nBullets ---\x3e Are fast and sharp (so deal damage)\\r\\n```\\r\\n\\r\\nNote that this is also how the real world works.<br/>\\r\\nThe real world doesn\'t care if something is a \\"bullet\\", or a \\"train\\".\\r\\nIf you get hit by either one at great speeds, you will probably die.\\r\\n\\r\\nSo the best way to describe this kind of idea, is representing the game\\r\\nin a more natural format.\\r\\n\\r\\nThis is both a bad idea, and a good idea.\\r\\n\\r\\n-----------------\\r\\n\\r\\n- *Why is natural emergence a good idea?*\\r\\n\\r\\nWell, in future, players might be able to come up with creative damage devices.\\r\\nSuch as custom mechanical cannons, or lining up shrapnel near\\r\\nexplosives to kill enemies.\\r\\n\\r\\nIt opens the game rules, and allows players to think outside of the developer\'s\\r\\nbox. Remember; it\'s all about allowing the player to create their own gameplay.[^1]\\r\\nIf we provide natural, emergent rules, this is much more viable.\\r\\n\\r\\n\\r\\n- *Why is natural emergence a bad idea?*\\r\\nLets talk about what I call the \\"Friendly-Fire dilemma\\".\\r\\n\\r\\n#### The Friendly-Fire dilemma\\r\\n\\r\\nEmergent systems are not without costs;<br/>\\r\\nThe biggest cost of an emergent game system is the loss of developer control.\\r\\n\\r\\nLets recap on our example from before.\\r\\n```\\r\\nFast moving, sharp entities ---\x3e Deal damage\\r\\nBullets ---\x3e Are fast and sharp (so deal damage)\\r\\n```\\r\\n\\r\\nNow, lets create a quick example that could be seen in game:\\r\\n```\\r\\nFast moving, sharp entities ---\x3e Deal damage\\r\\nBullets ---\x3e Are fast and sharp (so deal damage)\\r\\n\\r\\nPlayers shoot bullet at zombie, miss and hit friend --\x3e Player kills friend!\\r\\n```\\r\\n\\r\\nSuddenly, we have a situation where players can accidentally shoot\\r\\nand kill their friends, which, (at face value,) is bad.\\r\\n\\r\\nI call this the \\"Friendly Fire dilemma\\".\\r\\n\\r\\nTo put it frankly, this is the cost that we pay for emergent systems.\\r\\nSometimes our rules will have unintended consequences that we cannot solve without\\r\\nfudging with the rules in an unnatural, non-emergent fashion.[^2]\\r\\n\\r\\nThankfully, these issues aren\'t a big deal generally; as players will actively work\\r\\n*WITH* the rules to achieve their goal, not against them.<br/>\\r\\nIf shooting team-members hurts the chances of meeting a goal,\\r\\nplayers probably won\'t do it.\\r\\n\\r\\nHere\'s a little impromptu equation that describes the whole idea quite nicely:\\r\\n\\r\\n```\\r\\nEmergence * DeveloperControl  =  CONSTANT\\r\\n```\\r\\n\\r\\nWith every unit of emergence we add, *by nature*, we lose control as a developer.\\r\\n\\r\\nSimilar to how John Conway couldn\'t control the shape of Gosper\'s Glider gun,\\r\\nand similar to how the creators of Chess couldn\'t control how the Sicilian defence worked,\\r\\nas a developer, you lose control of your game when you create emergent rulesets.\\r\\n\\r\\nNote that this isn\'t neccessarily a \\"bad\\" thing.<br/>\\r\\nWith chess, the Sicilian defence does not hurt chess\'s integrity; it\'s just part of the game.\\r\\n\\r\\nMainly, the loss of developer control is just something to keep in mind :^)\\r\\n\\r\\n\\r\\n----------------\\r\\n\\r\\n\\r\\n## Emergence in Super Auto Pets\\r\\n\\r\\nThis blog post is getting quite long, but this is still a really good example that I want to cover.\\r\\nThankfully, someone else has already done a pretty good analysis on SAP\'s mechanics that sums up some of my thoughts.\\r\\n\\r\\nSo instead of doing my own analysis, I am instead going to link that blog post:\\r\\n[Have a read if you are extra interested.](https://a327ex.com/posts/super_auto_pets_mechanics)\\r\\n\\r\\nOne significant takeaway is that unit abilities don\'t operate in a closed fashion.\\r\\nSimilar to Isaac, abilities mesh with each other in an abstract fashion, which allows players to reason about the\\r\\ngame creatively and come up with their own strategies.\\r\\n\\r\\nSAP is also a pretty neat example, since it completely NAILS the simplicity aspect that was\\r\\ntalked about before.\\r\\n\\r\\n\\r\\n# TO CONCLUDE:\\r\\n\\r\\nIt\'s not about creating \\"more interesting\\" gameplay, or providing\\r\\na \\"more in-depth\\" experience for the player.\\r\\n\\r\\nRather, it\'s about providing the player with sufficiently emergent rules, such that they can\\r\\ncreate their OWN gameplay.\\r\\n\\r\\n- *Emergence on its own won\'t cut it. You need Emergence, combined with the human mind.*\\r\\n\\r\\nThanks for reading this opinion piece!\\r\\n\\r\\n- Oli\\r\\n\\r\\n\\r\\n----------------\\r\\n\\r\\n[^1]: When I say that a player \\"Creates gameplay\\", I mean that the player executes actions, sets goals, or interacts with the game world in a way that the developer did not directly specify. For example, a chess player executing a discovered attack with their knight. The creators of chess did not \\"create\\" this mechanic, this mechanic was instead \\"created\\" by the players.\\r\\n\\r\\n[^2]: YES, we *could* easily hardcode it so that bullets shot by a player don\'t harm players. But this kinda goes against the point of emergent rulesets in the first place. The whole point of an emergent ruleset is so that the players can mesh with the rules in a creative fashion! If we put in restrictions like this, we are closing corridors of opportunity. This situation where players can harm their allies? This can also be a GOOD situation, if you look at it a bit differently. Suddenly, friendly-fire is now a mechanic of the game; a mechanic that must be taken into account when approaching levels/situations. Also, fudging with the rules in this fashion is highly unintuitive from a player PoV. Why do my bullets not deal damage to my buddies, but crashing a car into my buddies does deal damage? If we want the player to understand our rules intuitively, fudging with rules like this is a bad idea."}]}')}}]);