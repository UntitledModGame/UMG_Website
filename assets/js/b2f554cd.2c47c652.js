"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"results_orientated_gamedev","metadata":{"permalink":"/blog/results_orientated_gamedev","source":"@site/blog/2023-10-04_results_orientated.md","title":"Results orientated gamedev, and why it\'s bad","description":"I think that developing games purely from a results-orientated perspective is bad.","date":"2023-10-04T00:00:00.000Z","formattedDate":"October 4, 2023","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"opinion","permalink":"/blog/tags/opinion"}],"readingTime":3.94,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"results_orientated_gamedev","title":"Results orientated gamedev, and why it\'s bad","tags":["design","opinion"]},"nextItem":{"title":"UMG Idioms","permalink":"/blog/umgidioms"}},"content":"I think that developing games purely from a results-orientated perspective is bad.\\r\\nThis article will explain my reasoning, and is a successor to [my other article on emergence.](../emergence)\\r\\n\\r\\n\x3c!-- truncate --\x3e\\r\\n\\r\\n### UH OH: HOT TAKES INCOMING!\\r\\n\\r\\nIn this article, I discuss the difference between \\"results orientated\\" development, and \\"systems orientated\\" development.\\r\\n\\r\\nOk. So what do I mean when I say \\"results orientated\\"?<br/>\\r\\nWhen I say a development cycle is \\"results orientated\\", I mean that the developers start with the player interactions/gameplay in mind, and develop the product from there.\\r\\n\\r\\n------------------\\r\\n\\r\\nTake for example, this development cycle:\\r\\n- \\"We want gameplay where the players shoot zombies, and build fortifications to defend against zombies\\".\\r\\n\\r\\nOk.<br/>\\r\\nWith this goal in mind, the development cycle will continue as expected... When the cycle is finished, we will have a basic product. Players will be able to build fortifications, and use their guns to fend off the waves of undead.<br/>\\r\\n\\r\\nBut the problem with this setup is that we have (probably) created a highly one-dimensional setup.<br/>\\r\\nDoes it matter if we have hordes of undead to fight, if our systems aren\'t good?\\r\\n\\r\\nWhen I talk \\"systems\\", I don\'t mean invisible architecture; I mean real systems that the player can observe and intuitively interact with.<br/>\\r\\nThe building/fortification system is great! cool! But did we implement it in a way that gives depth, *beyond* the closed scope of the development cycle?<br/>\\r\\nSure, our fortifications are great at dealing with zombies! But next update, we are adding multiplayer. Will our fortifications be able to deal with an onslaught of raiders from the other side of the server?<br/>\\r\\nMaybe! But even if they *do* succeed in fending off player raiders, they weren\'t meant to, and we got lucky.<br/>\\r\\nAnd this is our problem.\\r\\n\\r\\nIt would be much better if we started off with a more generic goal, and started development from a *systems orientated* perspective.\\r\\n\\r\\nFor example:\\r\\n- \\"We want a system where the player can manipulate structures to serve their goals\\"\\r\\n\\r\\nAlready, this looks way more promising.<br/>\\r\\nLets ignore zombies. Lets ignore raiders. Lets just give our players the *tools* to create and manipulate structures in a comprehensive fashion. From there, whatever other systems/mechanics we may add in the future, they are guaranteed to mesh well with our building system, since we made our system open ended.\\r\\n\\r\\nI call this, \\"systems orientated\\" development.\\r\\n\\r\\n-----------------\\r\\n\\r\\n# Chess!\\r\\n\\r\\n![chess](images/chess2.jpg)\\r\\n\\r\\n----------------\\r\\n\\r\\nChess is epic.<br/>\\r\\nIt\'s one of the best games to ever exist. And it\'s popularity proves it.\\r\\n\\r\\nChess was a game that was developed from a \\"systems orientated\\" perspective, as opposed to a \\"results orientated\\" perspective.\\r\\n\\r\\n-------\\r\\n\\r\\nOk! Lets have a look at some of the core mechanics of chess, and lets imagine what Chess would look like if it was developed with the end-result in mind.\\r\\n\\r\\n--------\\r\\n\\r\\n**Forks.** <-- These things [are an important part of chess.](https://en.wikipedia.org/wiki/Fork_(chess))<br/>\\r\\nHowever, lets stop to ponder.\\r\\n\\r\\nThe genius cavemen who created chess... did they develop chess with forks in mind? \\r\\n\\r\\n- **Caveman Bob:** \\"Hey Caveman Fred, ooga booga. You know what I want? I want a game where there are [PINS](https://en.wikipedia.org/wiki/Pin_(chess)), and [FORKS!](https://en.wikipedia.org/wiki/Fork_(chess))\\"\\r\\n- **Caveman Fred:** \\"Ooga booga, that sounds like a GREAT idea!\\"\\r\\n\\r\\nSo I can guarantee that this never happened.<br/>\\r\\nWhy? Well, because forks and pins *don\'t exist outside of chess.*<br/>\\r\\nThey were created as a result of chess\'s amazing systems.\\r\\n\\r\\nIf we try to create truly interesting/emergent gameplay from a results-orientated perspective, we will fail. Because the most interesting game mechanics simply *don\'t exist*, unless the systems exist to back them up.\\r\\n\\r\\nConsider:\\r\\n- **Caveman Bob:** \\"How about we make a game where positional strategy is really important?\\"\\r\\n- **Caveman Fred:** \\"Ooga booga! OK!\\"\\r\\n- **Caveman Bob:** \\"Hmm. We need a system where pieces can link up and connect with each other.\\"\\r\\n- **Caveman Fred:** \\"What if pieces can capture other pieces? That way, by positioning your pieces, you can protect them.\\"\\r\\n\\r\\nFrom there, Fred and Bob would go on to create the most influential game in human history, (besides Go).\\r\\n\\r\\nNote that they didn\'t start with a direct end goal in mind. They started with a vague idea for an interesting concept.<br/>\\r\\nBob and Fred developed chess from a *systems-orientated* perspective. And as a result, pins and forks were implemented for *free*, which are super important gameplay elements in chess.\\r\\n\\r\\nAnd that\'s pretty much my main point.\\r\\n\\r\\nI know, it feels weird. It feels dumb. My inner project-manager is enraged!<br/>\\r\\nBut I truly believe that developing systems, and having [systematic emergence](../emergence) in games is **way more important** than having a direct end-result that you can work towards.\\r\\n\\r\\n---------------\\r\\n\\r\\nGood systems create gameplay.<br/>\\r\\nBut good gameplay cannot create systems.\\r\\n\\r\\nThanks for reading this opinion piece! :)\\r\\n- Oli"},{"id":"umgidioms","metadata":{"permalink":"/blog/umgidioms","source":"@site/blog/2023-09-30_umg_idioms.md","title":"UMG Idioms","description":"A list of idioms for the UMG ecosystem.","date":"2023-09-30T00:00:00.000Z","formattedDate":"September 30, 2023","tags":[{"label":"coding","permalink":"/blog/tags/coding"},{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":3.24,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"umgidioms","title":"UMG Idioms","tags":["coding","umg"]},"prevItem":{"title":"Results orientated gamedev, and why it\'s bad","permalink":"/blog/results_orientated_gamedev"},"nextItem":{"title":"How should we represent entity properties?","permalink":"/blog/properties"}},"content":"A list of idioms for the UMG ecosystem.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n-----------------\\r\\n\\r\\n# Checking if an entity has a component:\\r\\n```lua\\r\\nif ent.foo then\\r\\n    print(\\"entity has component foo!\\")\\r\\nend\\r\\n```\\r\\nThis is the same as `ent:hasComponent(\\"foo\\")`\\r\\n\\r\\n------------------\\r\\n\\r\\n# Base-mod files:\\r\\nThese files aren\'t compulsory, but it is common practice to put them in base mods:\\r\\n\\r\\n`mod/components.md` - defines the components for this mod, in markdown<br/>\\r\\n`mod/mod_questions.lua` - where `umg.defineQuestion` is used<br/>\\r\\n`mod/mod_events.lua` - where `umg.defineEvent` is used<br/>\\r\\n\\r\\n\\r\\n------------------\\r\\n\\r\\n# Runtime client/server checks:\\r\\nOften, we will have code that is running on BOTH client-side AND server-side.<br/>\\r\\n(For example, the `onDeath` callback)\\r\\n\\r\\nTo get server/client specific behaviour, we can check what side we are on at runtime!\\r\\n```lua\\r\\nlocal function onDeath(ent)\\r\\n    -- called on client AND server.\\r\\n    if server then\\r\\n        -- this branch is only ran on server.\\r\\n        print(\\"I AM FROM SERVER\\")\\r\\n    elseif client then\\r\\n        -- only ran on client! :)\\r\\n        print(\\"hi from client!\\")\\r\\n    end\\r\\nend\\r\\n```\\r\\nYou get the idea! :)\\r\\n\\r\\n------------------\\r\\n\\r\\n# Classes:\\r\\nLua doesn\'t have classes, neither does the UMG engine.<br/>\\r\\nHowever, the `objects` base mod provides classes:\\r\\n```lua\\r\\nlocal MyClass = objects.Class(\\"my_mod:MyClass\\")\\r\\n\\r\\nfunction MyClass:init(...)\\r\\n    -- init is a special function that is called on instantiation\\r\\n    print(\\"init!\\", ...)\\r\\nend\\r\\n\\r\\nfunction MyClass:method()\\r\\n    print(\\"method call: \\", self)\\r\\nend\\r\\n\\r\\nlocal obj = MyClass(1,2,3)\\r\\n-- prints:  init! 1 2 3\\r\\n```\\r\\nThe reason this is better than `setmetatable`, is because `objects.Class` \\r\\nwill automatically register `MyClass` with `umg.register`.\\r\\n\\r\\n(WARNING: When defining a class, make sure to define on BOTH client AND server!!!\\r\\nElse, you\'ll run into big bad issues.)\\r\\n\\r\\n----------------\\r\\n\\r\\n\\r\\n# Component-wise bus response:\\r\\nListen to an event/question, and only respond if the entity has a certain component:<br/>\\r\\nThis setup is VERY common (and important) in UMG.\\r\\n\\r\\n- If an entity has the `.halo` component:\\r\\n    - --\x3e draw a circle above it.\\r\\n```lua\\r\\numg.on(\\"rendering:drawEntity\\", function(ent)\\r\\n    if ent.halo then\\r\\n        -- draw a halo above the entity!\\r\\n        love.graphics.circle(\\"line\\", ent.x, ent.y - 10, 5)\\r\\n    end\\r\\nend)\\r\\n```\\r\\n\\r\\nComp-wise bus response also works with question buses too:\\r\\n- If an entity is covered in goo:\\r\\n    - --\x3e slow the entity\\r\\n```lua\\r\\numg.answer(\\"xy:getSpeedMultiplier\\", function(ent)\\r\\n    if ent.goo then\\r\\n        return 0.5\\r\\n    end\\r\\n    return 1\\r\\nend)\\r\\n```\\r\\n\\r\\n------------------\\r\\n\\r\\n# Entity inheritance:\\r\\nSometimes, we may want to define an entity \\"base class\\", and extend it for a bunch of similar entity-types.\\r\\n\\r\\nWe can do this by defining a function that mutates an entity definition:\\r\\n```lua\\r\\n-- shared/abstract_entities.lua\\r\\n\\r\\n-- make sure its global!\\r\\nfunction enemyType(etype)\\r\\n    etype.category = \\"enemy\\",\\r\\n    etype.attack = etype.attack or {\\r\\n        type = \\"melee\\",\\r\\n        range = MELEE_RANGE\\r\\n    };\\r\\nend\\r\\n```\\r\\nAnd then, when we define our entities, we can access our global function `enemyType`:\\r\\n```lua\\r\\n-- entities/my_enemy.lua\\r\\n\\r\\nreturn enemyType({\\r\\n    image = \\"enemy1\\",\\r\\n    baseMaxHealth = 100,\\r\\n    baseStrength = 30\\r\\n})\\r\\n```\\r\\nYou get the idea :)\\r\\n\\r\\n\\r\\n------------------\\r\\n\\r\\n# Functions in components:\\r\\nYou may be horrified to realize that in UMG, doing this on serverside will cause a runtime error:\\r\\n```lua\\r\\nent.myComponent = function() end\\r\\n```\\r\\nThis is because in UMG, newly defined components are automatically sent over the network.<br/>\\r\\nAnd in UMG, functions can\'t be serialized; so an error is thrown.\\r\\n\\r\\nBut we *can* have functions as shared components, by defining them inside the entity type.<br/>\\r\\nThis is because shared-components aren\'t sent over the network.\\r\\n```lua\\r\\n-- my_mod/entities/my_entity.lua\\r\\nreturn {\\r\\n    myComponent = function() end\\r\\n    -- this is ok! :)\\r\\n\\r\\n    ...\\r\\n}\\r\\n```\\r\\n\\r\\n\\r\\n-----------------\\r\\n\\r\\n# Typecheck naming convention:\\r\\nWhen using `typecheck` mod, it\'s common to end the typecheck function with `Tc`.<br/>\\r\\nFor example:\\r\\n```lua\\r\\nlocal addTc = typecheck.assert(\\"number\\", \\"number\\")\\r\\n```\\r\\n(The `Tc` stands for \\"type check\\")\\r\\n\\r\\n-----------------------\\r\\n\\r\\n# Method-Event in base mods:\\r\\nWhen an event happens concerning an entity, it\'s common to do something like this:\\r\\n```lua\\r\\n-- ent dies!\\r\\nlocal function die(ent)\\r\\n    if ent.onDeath then\\r\\n        ent:onDeath()\\r\\n    end\\r\\n    umg.call(\\"mod:onDeath\\", ent)\\r\\nend\\r\\n```\\r\\n\\r\\nThis is quite flexible, since it allows for other systems to tag onto the death event, but it also allows entity-specific behaviour through our `onDeath` shared component.\\r\\n\\r\\nExamples of this: `mortality:entityDeath`, `rendering:drawEntity`"},{"id":"properties","metadata":{"permalink":"/blog/properties","source":"@site/blog/2023-09-23_properties.md","title":"How should we represent entity properties?","description":"How should properties be represented in video games?","date":"2023-09-23T00:00:00.000Z","formattedDate":"September 23, 2023","tags":[{"label":"coding","permalink":"/blog/tags/coding"},{"label":"design","permalink":"/blog/tags/design"}],"readingTime":4.37,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"properties","title":"How should we represent entity properties?","tags":["coding","design"]},"prevItem":{"title":"UMG Idioms","permalink":"/blog/umgidioms"},"nextItem":{"title":"Common lua idioms","permalink":"/blog/luaidioms"}},"content":"How should properties be represented in video games?<br/>\\r\\nI.e, maxHealth, damage, speed?\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nThe naive approach is to directly mutate the value:\\r\\n```lua\\r\\nent.damage = 5\\r\\n\\r\\n-- If we want to increase/decrease damage, just add/subtract:\\r\\nent.damage += 5 -- increase \\r\\nent.damage -= 5 -- decrease :) \\r\\n```\\r\\n\\r\\nBut this approach falls apart as soon as we add damage modifiers:\\r\\n```\\r\\nIf ent inside circle\\r\\n    gain 2 dmg\\r\\n```\\r\\nSuddenly, we have to increase/decrease `ent`s damage every time we enter/exit the circle.<br/>\\r\\nAnd it gets a bit mucky... What happens if we have these two rules:\\r\\n```\\r\\nIf ent inside circle\\r\\n    gain 2 dmg\\r\\n\\r\\nIf ent inside square\\r\\n    multiple dmg by 2\\r\\n```\\r\\nNow imagine the following events:\\r\\n```\\r\\nent dmg = 5\\r\\n\\r\\nent enters circle (dmg = 5+2 = 7)\\r\\nent enters square (dmg = 7*2 = 14)\\r\\nent leaves circle (dmg = 14-2 = 12)\\r\\nent leaves square (dmg = 12/2 = 6)\\r\\n\\r\\nent dmg = 6\\r\\n```\\r\\nUh oh!<br/>\\r\\nYeah we clearly need a smarter system.\\r\\n\\r\\n# Ok. How should we do it then?\\r\\n\\r\\nLets create some ideas!\\r\\n\\r\\n-----------\\r\\n\\r\\n## Modifier list\\r\\n\\r\\nIDEA: Have a list of `damageAdders` and `damageMultipliers` for our property.\\r\\n```\\r\\nent dmgMultipliers = []\\r\\nent dmgAdders = []\\r\\n```\\r\\n\\r\\nThis approach would involve having \\"modifiers\\" to the entity property, and when the entity\'s modifiers are changed, recalculate the property value.\\r\\n\\r\\nRecall our circle/square example:\\r\\n```\\r\\nent enters circle and square:\\r\\ndmgMultipliers = [2] \\r\\ndmgAdders = [2] \\r\\nrecalculation -> dmg = 14\\r\\n\\r\\nent exits:\\r\\ndmgMultipliers = [] \\r\\ndmgAdders = [] \\r\\nrecalculation -> dmg = 5\\r\\n```\\r\\n\\r\\nNow, TBH, I\'m really not a fan of this solution...<br/>\\r\\nMainly because the damage modifiers have to be added AND THEN removed. If we forget to remove it, then we\'re screwed!<br/>\\r\\nThis is due to it being stateful. I personally try to avoid state when I can.\\r\\n\\r\\n**PROS:**\\r\\n- Efficient: Only recalculates when something changes \\r\\n\\r\\n**CONS:**\\r\\n- Stateful, fragile\\r\\n\\r\\n------------\\r\\n\\r\\n\\r\\n## Recalculate per tick\\r\\nIf we have our damage system recalculate the entity\'s damage each tick,\\r\\nthen we don\'t need to worry about state, and our issues are solved.\\r\\n\\r\\nThat would look something like:\\r\\n```lua\\r\\neachTick(function() {\\r\\n    for ent in damageEntities {\\r\\n        ent.damage = calculateDamage(ent)\\r\\n    }\\r\\n})\\r\\n\\r\\nfunction calculateDamage(ent) {\\r\\n    dmg = ent.baseDamage\\r\\n    for shape in shapeList {\\r\\n        if shape.contains(ent) {\\r\\n            shape.buff(ent)\\r\\n        }\\r\\n    }\\r\\n    ... -- other calculations here\\r\\n    return dmg\\r\\n}\\r\\n```\\r\\n\\r\\nHowever, the main glaring \\"downside\\" with this approach is that damage values could be incorrect. Take the following example:\\r\\n\\r\\n- Every time I shoot a bullet, gain +2 damage for 5 seconds\\r\\n    - shoots 10 bullets in one tick\\r\\n    - --\x3e uh oh! All 10 bullets have the same damage!\\r\\n\\r\\n**PROS:**\\r\\n- No statefulness\\r\\n\\r\\n**CONS:**\\r\\n- Not the best for performance\\r\\n- Damage values may be incorrect, since it only refreshes per tick\\r\\n\\r\\n---------------------\\r\\n\\r\\n## Recalculate whenever\\r\\n\\r\\nTo avoid the above problem, we can recalculate more often.<br/>\\r\\nHow about we recalculate damage every time we need it? i.e:\\r\\n```lua\\r\\nfunction shootBullet(ent) {\\r\\n    dmg = calculateDamage(ent) -- same function as above.\\r\\n    bullet = newBullet(dmg)\\r\\n}\\r\\n```\\r\\nThis way, if we shoot 10 bullets, then our bullets are guaranteed to have the correct damage values.<br/>\\r\\nThe *downside* is that we are now having to recalculate every time we shoot. Not ideal!\\r\\n\\r\\nLikewise, whenever we want to even *access* the damage property, we must recalculate. That could be pretty bad; but again, it depends on how complex our damage recalculation setup is.\\r\\n\\r\\n**PROS:**\\r\\n- No statefulness\\r\\n- Guaranteed accuracy\\r\\n\\r\\n**CONS:**\\r\\n- Performance can be GARBO, depending on our setup\\r\\n\\r\\n-------------\\r\\n\\r\\n\\r\\n## Calculation tree + cache:\\r\\n\\r\\nImagine that we are recalculating the property every time we access it.<br/>\\r\\nLets say we have benchmarked our program, and we are running into performance issues due to our Shield system. Our shield system is really complicated, and it requires querying over a bunch of other entities when recalculating.\\r\\n\\r\\nWhat we could do here is split our setup into a tree:<br/>\\r\\nIn this example, the `damage` system is querying a bunch of calculator systems to obtain `damage`.\\r\\n\\r\\n```mermaid\\r\\nstateDiagram-v2\\r\\n    damage  --\x3e  shieldCalculator\\r\\n    damage  --\x3e  itemCalculator\\r\\n    damage  --\x3e  potionCalculator\\r\\n```\\r\\n\\r\\n-------------------\\r\\n\\r\\nWith this setup, we can convert the `shieldCalculator` system into a per-tick system, and add internal caching for efficiency.<br/>\\r\\nThis way, the other 2 systems (potions and items) can remain accurate, and it\'s only the shields that are slightly out of date.\\r\\n\\r\\nIf we STILL run into performance issues, we can recalculate shields every 5 ticks instead, for example.\\r\\n\\r\\nLikewise, if the potion system has a particular potion class that is problematic for performance, then the potion system could split itself up, and do some internal caching on \\"complex potions\\" to account:\\r\\n\\r\\n-------------------\\r\\n\\r\\n```mermaid\\r\\nstateDiagram-v2\\r\\n    damage  --\x3e  shieldCalculator\\r\\n    damage  --\x3e  itemCalculator\\r\\n    damage  --\x3e  potionCalculator\\r\\n    potionCalculator --\x3e normalPotions\\r\\n    potionCalculator --\x3e complexPotions\\r\\n```\\r\\n\\r\\n--------------\\r\\n\\r\\nWhat\'s cool, is that *all three* previous approaches work perfectly well with this tree setup.\\r\\n\\r\\nPerhaps the effect system already has some internal state upon entities? In that case, there would be no downside to the `Modifier list` approach.<br/>\\r\\nWe can have our cake, and eat it too.\\r\\n\\r\\n--------------\\r\\n\\r\\nTo understand to how the damage calculation system has been implemented in [UMG](../umgtech), take a look at [my article on question buses.](../buses)\\r\\n\\r\\nThanks for reading!\\r\\n- Oli"},{"id":"luaidioms","metadata":{"permalink":"/blog/luaidioms","source":"@site/blog/2023-09-22_idiomatic_lua.md","title":"Common lua idioms","description":"I have been using lua for a while. (About 4 years as of writing this!)","date":"2023-09-22T00:00:00.000Z","formattedDate":"September 22, 2023","tags":[{"label":"coding","permalink":"/blog/tags/coding"}],"readingTime":2.305,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"luaidioms","title":"Common lua idioms","tags":["coding"]},"prevItem":{"title":"How should we represent entity properties?","permalink":"/blog/properties"},"nextItem":{"title":"UMG has no versioning","permalink":"/blog/versioning"}},"content":"I have been using lua for a while. (About 4 years as of writing this!)<br/>\\r\\nIt\'s a language that I kinda grew up on, and I\'ve learned to love.<br/>\\r\\nThis article will contain a list of idioms that are common to see in lua.<br/>\\r\\nLets go!\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## Default values with `or`\\r\\n```lua\\r\\nlocal x = obj.x or 15\\r\\n-- in lua, accessing an undefined table value defaults to `nil`.\\r\\n-- `nil` and `false` are falsey values,\\r\\n-- So in this example,\\r\\n-- If `obj` doesnt have the `.x`, then it will fall back to 15.\\r\\n\\r\\n-- another common use case:\\r\\nobj.x = obj.x or 0\\r\\n\\r\\n```\\r\\n\\r\\n----------------\\r\\n\\r\\n## Optional arguments:\\r\\n\\r\\nIn lua, passing less or more arguments doesn\'t error.\\r\\n```lua\\r\\nlocal function f(x)\\r\\n    print(x)\\r\\nend\\r\\n\\r\\nf(1,2,3) -- this is fine. output: 1\\r\\nf() -- this is fine. output: nil\\r\\n```\\r\\n\\r\\nWe can use this to have optional arguments:\\r\\n```lua\\r\\n-- euclidean distance:\\r\\nlocal function distance(x, y, z)\\r\\n    z = z or 0 -- z is an optional argument!\\r\\n    local dx, dy, dz = x*x, y*y, z*z\\r\\n    return (dx+dy+dz) ^ 0.5\\r\\nend\\r\\n\\r\\n\\r\\nprint(distance(3,4)) -- 5\\r\\nprint(distance(3,4,5)) -- 7.071\\r\\n```\\r\\n\\r\\n---------------\\r\\n\\r\\n## Error on undefined access\\r\\n\\r\\nIn lua, if you access an undefined variable, that variable returns nil.\\r\\nExample:\\r\\n```lua\\r\\nprint(undefined_variable_34389439) -- nil\\r\\n-- no error!\\r\\n```\\r\\nThis is a bit weird, and some people don\'t like it.<br/>\\r\\nBut we can change this with `__index` and `setmetatable`.\\r\\n\\r\\nIn lua, `_G` is the special table that holds all the globals.\\r\\n```lua\\r\\nlocal function err(t,k,v)\\r\\n    error(\\"Accessed an undefined variable: \\" .. tostring(k))\\r\\nend\\r\\nsetmetatable(_G, {\\r\\n    __index = err\\r\\n})\\r\\n```\\r\\nNow, if we access an undefined variable:\\r\\n```lua\\r\\nprint(undefined_variable_34389439)\\r\\n-- Error: main.lua:4:\\r\\n-- Accessed an undefined variable: undefined_variable_34389439\\r\\n```\\r\\n\\r\\nYou can do the same with `__newindex` if you want to stop pollution of the global namespace on accident.\\r\\n\\r\\n------------------\\r\\n\\r\\n## Private class methods\\r\\nFor the OOP folks out there, who want private methods.\\r\\n\\r\\nOften in lua, you\'ll see a class setup like so:\\r\\n\\r\\n```lua\\r\\nlocal MyClass = Class()\\r\\n\\r\\nfunction Class:init()\\r\\n    self.x = 0; self.y = 0\\r\\nend\\r\\n\\r\\nfunction Class:privateHi()\\r\\n    -- ugh, I wish this could be private!\\r\\n    print(self)\\r\\nend\\r\\n\\r\\nfunction Class:hi()\\r\\n    self:privateHi()\\r\\n    print(\\"hiiii\\")\\r\\nend\\r\\n```\\r\\nPrivate methods can be done like so.\\r\\n```lua\\r\\n\\r\\nlocal function privateHi(self)\\r\\n    -- yay, now i am private!\\r\\n    print(self)\\r\\nend\\r\\n\\r\\nfunction Class:hi()\\r\\n    privateHi(self)\\r\\n    print(\\"hiiii\\")\\r\\nend\\r\\n```\\r\\nAt first, you may feel uneasy doing it this way, or you may feel cheated.<br/>\\r\\nRealize though, that all functions in lua are anonymous and first-class. `privateHi` has the exact same bytecode as `Class:privateHi`:\\r\\n```\\r\\n0000\\tFUNCF    4 \\r\\n0001\\tGGET     1   0      ; \\"print\\"\\r\\n0002\\tMOV      3   0\\r\\n0003\\tCALL     1   1   2\\r\\n0004\\tRET0     0   1\\r\\n```\\r\\nThe only difference is that one is inside a table, and one is a local.\\r\\n\\r\\n----------------------"},{"id":"versioning","metadata":{"permalink":"/blog/versioning","source":"@site/blog/2023-09-17_no_versioning.md","title":"UMG has no versioning","description":"In Untitled Mod Game, there is going to be no versioning of mods.","date":"2023-09-17T00:00:00.000Z","formattedDate":"September 17, 2023","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":5.235,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"versioning","title":"UMG has no versioning","tags":["design","umg"]},"prevItem":{"title":"Common lua idioms","permalink":"/blog/luaidioms"},"nextItem":{"title":"Why should I use an Entity Component System?","permalink":"/blog/ECS"}},"content":"In Untitled Mod Game, there is going to be no versioning of mods.<br/>\\r\\nThis is a very bold call, and it sounds stupid at face value.\\r\\nBut please, hear me out!<br/>\\r\\nThis lil article will explain my thought process.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n*(This article requires a basic understanding of my vision for Untitled Mod Game. If you are unfamiliar, [have a quick skim](../umgtech).)*\\r\\n\\r\\n---------------\\r\\n\\r\\nIn pretty much all software packaging systems, software has\\r\\nversion information.<br/>\\r\\nVersioning is great, because it allows introducing breaking changes to software without harming existing users.\\r\\n\\r\\nAnd that\'s pretty much the main \\"point\\" of versioning, is dealing with breaking changes. \\r\\nIf users don\'t want to deal with breaking changes, they can just stay on an older version.\\r\\n\\r\\nPros of versioning:\\r\\n- Allows developers to break compatibility in favour of better features or removal of tech debt\\r\\n- Users can use older versions if they want, granting a lot more freedom\\r\\n\\r\\nCons of versioning: (no major cons, really)\\r\\n- Userbase can become fragmented\\r\\n\\r\\n---------------\\r\\n\\r\\nNow, before we start, I\'d just like to note,\\r\\nI\'m **100% FOR** the use of versioning, and I think you\'d have to be an idiot not to see the value in it for 99% of situations.\\r\\n\\r\\nBut UMG is a bit special in what it\'s trying to achieve.<br/>\\r\\nThere\'s a very concerning situation where versioning could cause a bit of a mess, I\'ll explain it below.\\r\\n\\r\\n--------------------\\r\\n\\r\\nLet\'s do a thought experiment.<br/>\\r\\nLets assume that mods ARE versioned in UMG.\\r\\n\\r\\nAs discussed in [my other article](umgtech), a central goal of the UMG ecosystem is to ensure hyper-compatibility between mods.\\r\\n\\r\\nI want to be able to load the `ridable` mod, and have it work fully with the `projectiles` mod. That way, I can ride my horse off into the sunset, wielding my minigun, and rocking a cowboy hat.\\r\\n\\r\\nIdeally, the `projectiles` mod should not need to care about the `ridable` mod. In fact, both mods should not know about each other, since they are unrelated.<br/>\\r\\nHowever, both mods will still need to tag onto other mods.\\r\\nBoth the `projectiles` mod, and the `ridable` mod will need the `dimensions` mod to be loaded, so that they can fudge around with what dimensions steeds are in, and what dimensions projectiles are spawned in.\\r\\n\\r\\n```mermaid\\r\\nstateDiagram-v2\\r\\n    riding --\x3e dimensions_v0\\r\\n    projectiles --\x3e dimensions_v0\\r\\n```\\r\\n\\r\\nBut lets assume that there was a breaking change in the `dimensions` mod, from version 0.0 to version 1.0, which overhauled the way entities are stored inside of dimensions, and changed a few things about the API.\\r\\n\\r\\nLets say that the `riding` mod updated to the latest version, but the author of the `projectiles` mod disagreed with the changes, so they stayed on the older version.<br/>\\r\\nSuddenly, we would have a setup like so:\\r\\n\\r\\n```mermaid\\r\\nstateDiagram-v2\\r\\n    riding --\x3e dimensions_v1\\r\\n    projectiles --\x3e dimensions_v0\\r\\n```\\r\\n\\r\\nNow, what fricken SUCKS, is that `riding` and `projectiles` are no longer compatible.<br/>\\r\\nWhy? Because they use two different versions for the `dimensions` mod.\\r\\nWhen entites are emplaced into a world, their `.dimension` component is going to be handled (and mangled) by two competing systems; one in `dimensions_v1`, and one in `dimensions_v0`.<br/>\\r\\nThis is terrible.\\r\\n\\r\\nNow, one could argue that this \\"issue\\" is the fault of whoever wrote the dimensions mod.<br/>\\r\\nAnd I would 100% agree. But that\'s kinda ignoring the real issue here. The real issue, is that this setup, (where `riding` and `projectiles` use different versions) is ALLOWED to exist.\\r\\n\\r\\nThe `riding` mod works fine on it\'s own.<br/>\\r\\nThe `projectiles` mod works fine on it\'s own too!<br/>\\r\\n\\r\\nBut what\'s bad, is that this setup will spread like a cancer. Any mods that build on top of `riding` will no longer be able to use the `projectiles` mod. Same vice versa. We have created a situation where our beautiful degree of hyper-compatibility is killed.\\r\\n\\r\\nIt would have been much better if whoever wrote `projectiles` was instead forced to use `dimensions_v1`; that way, compatibility between mods is guaranteed.\\r\\n\\r\\n----------------\\r\\n\\r\\nTo hammer it home, here\'s a (simplified) version of the dependency tree for the existing UMG mod, `test`:\\r\\n\\r\\n\\r\\n```mermaid\\r\\n\\r\\nstateDiagram-v2\\r\\n    borders  --\x3e    dimensions\\r\\n    borders  --\x3e    rendering\\r\\n\\r\\n    base     --\x3e    typecheck\\r\\n\\r\\n    sync     --\x3e    reducers\\r\\n    base     --\x3e    objects\\r\\n    objects  --\x3e    typecheck\\r\\n    base     --\x3e    state_\\r\\n    state    --\x3e    objects\\r\\n    state    --\x3e    typecheck\\r\\n    state    --\x3e    reducers\\r\\n    base     --\x3e    input\\r\\n    input    --\x3e    objects\\r\\n    base     --\x3e    rendering\\r\\n    rendering        --\x3e    objects\\r\\n    rendering        --\x3e    typecheck\\r\\n\\r\\n    scheduling       --\x3e    typecheck\\r\\n    scheduling       --\x3e    objects\\r\\n    base     --\x3e    reducers\\r\\n    base     --\x3e    physics\\r\\n    physics  --\x3e    state_\\r\\n    physics  --\x3e    dimensions\\r\\n    physics  --\x3e    xy\\r\\n    xy       --\x3e    sync\\r\\n    xy       --\x3e    typecheck\\r\\n    xy       --\x3e    state_\\r\\n    xy       --\x3e    reducers\\r\\n    base     --\x3e    control\\r\\n    control  --\x3e    input\\r\\n    control  --\x3e    rendering\\r\\n    control  --\x3e    xy\\r\\n    control  --\x3e    sync\\r\\n    base     --\x3e    xy\\r\\n    base     --\x3e    follow\\r\\n    follow   --\x3e    control\\r\\n\\r\\n    juice    --\x3e    typecheck\\r\\n\\r\\n    base     --\x3e    initializers\\r\\n    initializers     --\x3e    dimensions\\r\\n    initializers     --\x3e    xy\\r\\n\\r\\n    ui       --\x3e    input\\r\\n    items    --\x3e    input\\r\\n\\r\\n    borders  --\x3e    objects\\r\\n    borders  --\x3e    typecheck\\r\\n    categories       --\x3e    base\\r\\n    categories       --\x3e    chunks\\r\\n    chunks   --\x3e    base\\r\\n    chat     --\x3e    base\\r\\n    commands         --\x3e    chat\\r\\n\\r\\n    crafting         --\x3e    base\\r\\n    crafting         --\x3e    items\\r\\n    grids    --\x3e    base\\r\\n    grids    --\x3e    categories\\r\\n    grids    --\x3e    typecheck\\r\\n\\r\\n    worldeditor      --\x3e    ui\\r\\n    worldeditor      --\x3e    chunks\\r\\n    modern   --\x3e    chunks\\r\\n    modern   --\x3e    chat\\r\\n    modern   --\x3e    ui\\r\\n    modern   --\x3e    grids\\r\\n    projectiles      --\x3e    mortality\\r\\n    projectiles      --\x3e    usables\\r\\n    test     --\x3e    base\\r\\n    test     --\x3e    juice\\r\\n\\r\\n    test     --\x3e    weather\\r\\n    weather  --\x3e    base\\r\\n    weather  --\x3e    light\\r\\n\\r\\n    test     --\x3e    borders\\r\\n\\r\\n    test --\x3e modern\\r\\n    test --\x3e projectiles\\r\\n\\r\\n```\\r\\n\\r\\nI simplified the diagram greatly, because the original was too cluttered and hard to read. (roughly half the edges have been omitted.)\\r\\n\\r\\nCan you *imagine* what a nightmare this would be, if every mod was able to use it\'s own versions for stuff?<br/>\\r\\nIt just wouldn\'t be possible. Versioning is not compatible with UMG\'s vision. \\r\\n\\r\\nBut as stated previously... versioning IS useful, mainly for dealing with breaking changes. So how does UMG deal with breaking changes?\\r\\n\\r\\nWell... it doesn\'t.<br/>\\r\\nBreaking changes will simply have to be avoided. To be fair, Java is a programming language [that has taken this exact approach](https://blog.jooq.org/the-lame-side-of-javas-backwards-compatibility/), and hey, they haven\'t done too poorly.\\r\\n\\r\\nThe main painstaking downside of this setup is that we are ASSUMING that the base mods are going to be developed in a forward thinking, robust manner.<br/>\\r\\nThat is, developed free of future tech debt, and developed with all future requirements predicted for, (an impossible task.)<br/>\\r\\nUnfortunetely, I don\'t believe there is another solution. C\'est la vie, brother!"},{"id":"ECS","metadata":{"permalink":"/blog/ECS","source":"@site/blog/2023-07-10_why_ecs.md","title":"Why should I use an Entity Component System?","description":"ECSes are really cool and fun! This article will explain why I love them so much.","date":"2023-07-10T00:00:00.000Z","formattedDate":"July 10, 2023","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"opinion","permalink":"/blog/tags/opinion"}],"readingTime":8.11,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"ECS","title":"Why should I use an Entity Component System?","tags":["design","opinion"]},"prevItem":{"title":"UMG has no versioning","permalink":"/blog/versioning"},"nextItem":{"title":"Technical implementation details for UMG","permalink":"/blog/umgtech"}},"content":"ECSes are really cool and fun! This article will explain why I love them so much.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nIf you drop an apple from an aeroplane, sooner or later, it will hit the ground,\\r\\nand no longer be an apple.<br/>\\r\\nAnd the same can be said about pears. And bananas. And most other objects,\\r\\nfor that matter.\\r\\n\\r\\nThe reason this happens is because of gravity.\\r\\nGravity is a rule that works on every object in the universe, which is how rules are supposed to work.\\r\\n\\r\\n-----------\\r\\n\\r\\n![apple_falling](images/apple_falling.jpg)\\r\\n\\r\\n------------\\r\\n\\r\\nIn software development, it seems like a lot of rules aren\'t programmed this way.\\r\\nWith the rise of OOP, programmers have been fixated on binding behaviour to objects,\\r\\ninstead of binding behaviour to the system itself.\\r\\n\\r\\nAnd in gamedev, this is something that has been challenged. (a lot.)\\r\\nClassic Entity Component System (ECS) architecture goes as far to say that no behaviour\\r\\nshould be bound to game entities at all; they should only have data, and systems (rules)\\r\\nshould then act on that data in a global fashion.\\r\\n\\r\\nTo sum it up from a gamedev perspective:<br/>\\r\\n- In classic OOP fashion, game entities contain functions. These functions define the behaviour of the entity.\\r\\n- In classic pure ECS architecture, game entities are not allowed to contain functions. Behaviour is instead defined by \\"systems\\", which are external scripts that act on entities.\\r\\n\\r\\n\\r\\nBut hang on... what even is a component? Or an entity, or a system?\\r\\n\\r\\n\\r\\nConcept\\t  | Explanation\\r\\n----------|-----------\\r\\nComponent |\\tPlain old data with a name. Like a position, or an image\\r\\nEntity    | A game object. E.g. an apple, truck, or human. Contains one or more components, grouped together. Does not contain code\\r\\nSystem\\t  | Code that processes all entities with certain components\\r\\n\\r\\n\\r\\n![ecs](images/ECS.png)\\r\\n\\r\\nTo better explain, I\'ll write a quick hacky example in pseudocode:\\r\\n\\r\\nEntities / components:\\r\\n```lua\\r\\n-- an entity containing x, y, image components\\r\\nlocal ent = {\\r\\n    x = 5, -- `x` component\\r\\n    y = 15, -- `y` component\\r\\n    image = \\"cat\\" -- `image` component\\r\\n}\\r\\n```\\r\\n\\r\\nSystems:\\r\\n```lua\\r\\n--[[\\r\\nThis is a view of entities that have all these components: (x, y, image)\\r\\n(We don\'t care what other components the entity may have.)\\r\\n]]\\r\\nlocal drawEntities = entityGroup<x, y, image>()\\r\\n\\r\\nfunction draw() {\\r\\n    -- called whenever we draw to screen\\r\\n    for ent in drawEntities {\\r\\n        draw(ent.image, ent.x, ent.y)\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n\\r\\nIn this example, we create a global rule.<br/>\\r\\nWe say: for all entities that have `x, y, image` components,\\r\\nwe will draw these entities to the screen.\\r\\n\\r\\nSimilar to how gravity is applied globally to all objects,\\r\\nwe are applying our draw rule globally to all entities that fit the profile.\\r\\n\\r\\nThis allows us to create much more natural rules, which can give way for some nice emergence.\\r\\n(I wrote [another blog post on emergence](../emergence), you should give it a read!)\\r\\n\\r\\nHowever, the biggest benefit to ECS is not actually the \\"naturalness\\" of it;\\r\\nrather, the biggest benefit is *scalability in design.*<br/>\\r\\nWe have applied a *global* rule to entities. And if you know anything about software\\r\\ndesign, alarm bells should be going off right now. Generally, global state and\\r\\nglobal behaviour is really bad, since it leaks out into the rest of the software and causes\\r\\na big mess.<br/>\\r\\nBut in this case, our global rule is not actually leaking anywhere.<br/>\\r\\nIt\'s entirely contained within the draw system. Isn\'t that beautiful?<br/>\\r\\nWhen we go write a new system, we don\'t need to care AT ALL about this global rule we made.\\r\\nThe only thing we need to care about are the components. But that\'s completely fine,\\r\\nbecause those entities were going to have those components anyway. Besides, there is no\\r\\nfunky behaviour tied up in the components; they are just data.\\r\\n\\r\\nIn fact, we can even create a new system, say, `AnimationSystem` that changes the `image` component\\r\\nwith respect to time to give entities an animation effect.\\r\\nWhat\'s beautiful, is that the `AnimationSystem` *does not need to care* about the draw system at all.\\r\\nThe systems are effectively communicating through components.\\r\\n\\r\\nAnd we don\'t stop there. We can keep scaling. We can keep adding as many systems, as many rules as we want,\\r\\nand none of the systems will ever need to interact with each other.\\r\\nAnd with every system we add, remember that the rules are applied *globally*.\\r\\n\\r\\nAnd that\'s what I find so amazing about this setup. Each system is just fudging with data.\\r\\nNo system needs to know more than neccessary; there are no monolithic systems that know too much,\\r\\nevery system only takes the bare minimum, and outputs the bare minimum.\\r\\nAnd we can afford to do the minimum, because our rules are applied globally; although are\\r\\nrules may not be doing much on their own, if we add all our rules together, we get a big complex\\r\\nsystem that is super easy to break down.\\r\\n\\r\\nAnd that\'s it! I probably ranted for too long here, but you get the idea.<br/>\\r\\nI see a lot of articles online praising ECS for it\'s cache performance benefits, and it\'s\\r\\nability to handle large swathes of entities. While this is true, I think what\'s more important is the\\r\\narchitectural side of it.\\r\\nIt allows us to handle massively complex systems whilst still being hyper-modular and hyper-generic.\\r\\n\\r\\n-----------------\\r\\n\\r\\nBefore I end this blog post, I want to discuss what I use for my project.\\r\\nBecause I don\'t exactly use a pure ECS as it stands, but most of my ideas have been\\r\\nadapted from the classic ECS setup:\\r\\n\\r\\n## What does UMG do?\\r\\n\\r\\nUntitled Mod Game is a project I\'ve been working on for a while.\\r\\nUMG uses a \\"special\\" ECS setup.<br/>\\r\\nI call it \\"special\\", because we break a few rules:\\r\\n\\r\\n**RuleBreak 1:** in UMG, entities are typed. (Classic ECS has no types for entities)<br/>\\r\\n**RuleBreak 2:** in UMG, entities can contain functions (OMG!!! EVIL!)<br/>\\r\\n\\r\\nTo visualize things, here is what an entity definition could look like in UMG:\\r\\n```lua\\r\\n-- a button entity that resets the board state when clicked\\r\\n\\r\\nlocal resetButton = {\\r\\n    image = \\"button1\\",\\r\\n\\r\\n    buttonPressAnimation = {\\r\\n        frames = {\\"button1\\", \\"button2\\", \\"button3\\"},\\r\\n        time = 0.5\\r\\n    },\\r\\n\\r\\n    buttonPressSound = \\"click\\"\\r\\n\\r\\n    onButtonPress = function(ent)\\r\\n        board:reset()\\r\\n    end\\r\\n}\\r\\n```\\r\\n\\r\\nSo, what\'s the reasoning behind breaking these two rules?\\r\\n\\r\\nRule 1 (entities having types) is broken partially for efficiency reasons.<br/>\\r\\nWith types, we can share static data across entities of the same type. \\r\\nIt also means that redundant data doesn\'t need to be sent over the network.\\r\\nAll in all, it\'s just a bit nicer.[^1]\\r\\n\\r\\n\\r\\nRule 2 (entities containing functions) is broken for practical reasons.<br/>\\r\\nIn my opinion, practicality is ALWAYS more important than ideology.\\r\\nSure, in theory, it makes sense for entities to never contain functions.<br/>\\r\\nBut what about really niche cases? For example, what if I want to make a gun that clones entities when shot?<br/>\\r\\nWell, let\'s try implement it!\\r\\n\\r\\nWe have a few options here:<br/>\\r\\n\\r\\n**OPTION 1:** Hardcode the clone gun behaviour inside a system that only the clone gun uses.  (Bad, because we are creating a global rule that will only affect one entity type)<br/>\\r\\n**OPTION 2:** Create a sophisticated command-template system. The clone gun can then use an on-hit clone command that\'s ran when the bullet hits an entity. (Better, but a blatant violation of YAGNI.)<br/>\\r\\n**OPTION 3:** Hardcode the clone gun behaviour inside a function within the clone gun entity. (Violation of pure ECS principles, but other than that, the easiest solution)\\r\\n\\r\\nOption 1 is obviously stupid, so lets just ignore it.\\r\\n\\r\\nLets look at what option 2 could look like:\\r\\n```lua\\r\\n-- clone gun entity:\\r\\nlocal cloneGun = {\\r\\n    gun = { bullets = 1, bulletSpeed = 200 },\\r\\n\\r\\n    bulletHitEffect = {\\r\\n        {effect = \\"clone\\", target = \\"target\\"}\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n-- But remember, we also need a system to intercept the bullet behaviour:\\r\\n-- bulletSystem.lua:\\r\\n\\r\\nlocal effects = {\\r\\n    ...\\r\\n}\\r\\nlocal targets = {\\r\\n    ...\\r\\n}\\r\\n\\r\\numg.on(\\"entityCollide\\", function(e1, e2)\\r\\n    if e1.bullet then \\r\\n        -- logic for applying the bullet hit effect here.\\r\\n        ... -- apply effect enum to target\\r\\n    end\\r\\nend)\\r\\n\\r\\n\\r\\n```\\r\\n\\r\\n\\r\\nAnd now, the 3rd option:\\r\\n```lua\\r\\n-- clone gun entity:\\r\\nlocal cloneGun = {\\r\\n    gun = { bullets = 1, bulletSpeed = 200 },\\r\\n\\r\\n    -- In this example, we put the cloning behaviour directly inside of the\\r\\n    -- clone gun entity.\\r\\n    -- This is a violation of ECS principles, because behaviour is supposed to be\\r\\n    -- applied globally...     but it gets the job done.\\r\\n    bulletHit = function(ent, bulletEnt, hitEnt)\\r\\n        hitEnt:deepClone()\\r\\n    end\\r\\n}\\r\\n```\\r\\n\\r\\nIn an ideal world, option 2 would be the best. \\r\\n\\r\\nBut the world is not ideal. Us programmers have limited time.<br/>\\r\\nAnd in the case of UMG, *modders* have limited patience.\\r\\nAre people really going to want to create a whole new system just to clone an entity?<br/>\\r\\nHell nah! People probably just want to see themselves clone their buddies as fast as possible.\\r\\n\\r\\nSo therefore, UMG allows functions inside of entities.\\r\\nNot because its good, but because I believe **practicality > ideology**.\\r\\n\\r\\nAnyway, that\'s it for this blog post.\\r\\n\\r\\nThanks for reading this opinion piece!\\r\\n\\r\\n- Oli\\r\\n\\r\\n\\r\\n\\r\\n[^1]: (Quick note: In most ECSes, entities having no types is due to entities being represented as a single integer. From there, component data is packed into big cache-friendly PoD arrays that systems can zoom over and transform super quickly. UMG is using lua, which doesn\'t have the cache optimization opportunities that most low level languages have. Hence, entities being explicit types is not harmful to performance since we can\'t optimize for cache misses anyway lol! I just wanted to emphasize this, because I made it sound like entities being untyped came from an architectural standpoint, whereas it\'s rather mainly from a performance standpoint.)"},{"id":"umgtech","metadata":{"permalink":"/blog/umgtech","source":"@site/blog/2023-06-2_umg_tech_details.md","title":"Technical implementation details for UMG","description":"----------------------------","date":"2023-06-02T00:00:00.000Z","formattedDate":"June 2, 2023","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"umg","permalink":"/blog/tags/umg"},{"label":"coding","permalink":"/blog/tags/coding"}],"readingTime":8.475,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"umgtech","title":"Technical implementation details for UMG","tags":["design","umg","coding"]},"prevItem":{"title":"Why should I use an Entity Component System?","permalink":"/blog/ECS"},"nextItem":{"title":"Question buses in UMG","permalink":"/blog/buses"}},"content":"\x3c!--truncate--\x3e\\r\\n\\r\\n----------------------------\\r\\n\\r\\n\\"Untitled Mod Game\\" (or \\"UMG\\" in short) is a multiplayer\\r\\ngame that is based on mods.\\r\\n\\r\\nI\'ve been developing it for many months at this point, and it\'s been really fun!\\r\\n\\r\\nIt\'s setup is similar to that of Garrys Mod,\\r\\nwhere most playable content is User-generated.\\r\\n\\r\\n------------------------------\\r\\n\\r\\nHowever, UMG seeks to take things a bit further, and address\\r\\na few issues that exist with the traditional traditional modding approach.\\r\\n\\r\\n**Traditional modding approach:**\\r\\n\\r\\n![traditional](images/regular_modding.png)\\r\\n\\r\\n-------------------\\r\\n\\r\\nWith UMG, we have two \\"types\\" of mods: \\"Base\\" and \\"Playable\\" mods.\\r\\n\\r\\n- Base mods:\\r\\n    - provide tools and infrastructure for modders to create content\\r\\n    - do not provide any playable content\\r\\n\\r\\n- Playable mods:\\r\\n    - provide gameplay and content\\r\\n\\r\\nWhat\'s interesting about this setup, is that there is no \\"game\\".\\r\\n*Everything* is built as a mod.<br/>\\r\\nHere\'s a diagram of what UMG would look like, under the same setup:\\r\\n\\r\\n![cooperative_modding](images/cooperative_modding.png)\\r\\n\\r\\n---------------\\r\\n\\r\\nBut, what\'s the point of this?<br/>\\r\\nHow is this any better than the former setup?<br/>\\r\\n\\r\\nTo explain the point of this, we need to understand what I call\\r\\n\\"The Riding problem\\".\\r\\n\\r\\n# The riding problem:\\r\\n\\r\\nLets imagine that we have 2 modders, \\"John\\" and \\"Mary\\".\\r\\n\\r\\nMary likes elephants, so she is making an elephant riding mod.\\r\\nJohn likes horses, so he is making a mod where you can ride horses.\\r\\n\\r\\nBoth Mary and John go about their business, and create their mods.\\r\\nSince there is no way for John and Mary to communicate, they both code\\r\\nthe riding behaviour independently.\\r\\n\\r\\nThis is *terrible*.<br/>\\r\\nWhy?  Well, the code for riding animals has been written twice independently.\\r\\nWhich is a big waste of time!\\r\\n\\r\\nIt would be much better if John and Mary\'s mods both \\"extended\\" a common mod,\\r\\ne.g, the \\"Ridable Animals Mod\\".\\r\\nThis way, code is only written once in a generic fashion, and time is saved.\\r\\n\\r\\nBut actually, there\'s a bigger problem than \\"duplicate code\\": *Compatibility.*<br/>\\r\\nImagine if someone loads the ridable elephants mod, and the ridable horses mod at the same time.<br/>\\r\\nImagine the player jumps on a horse, and then goes over to an elephant,\\r\\nand tries to ride the elephant *whilst riding* the horse.\\r\\n\\r\\nAt best, nothing happens.<br/>\\r\\nAt worst, the game crashes, or they get glitched across the world in an unpredictable fashion.\\r\\n\\r\\nWithout John and Mary following a standard protocol, there is no way for them\\r\\nto know if they are breaking each others work.\\r\\n\\r\\n-----------------------------\\r\\n\\r\\nIdeally, in UMG, the \\"ridable\\" behaviour would be extrapolated to a \\"Base\\" mod.\\r\\nThe \\"Playable\\" mods, (ridable horses and ridable elephants) could then extend the \\"ridable\\" mod.\\r\\n\\r\\n# Technical implementation:\\r\\nSo this setup is cool and all, but how would this work in a technical sense?<br/>\\r\\nHow do mods know about each other in this way?<br/>\\r\\nAlso, what stops other base mods from being incompatible with each other, causing the same class of problems?\\r\\n\\r\\nTo understand this, lets do a quick overview of UMG architecture:\\r\\n\\r\\n## The UMG Entity Component System:\\r\\n*If you have never heard of ECSes in a gamedev context, I recommend looking it up real quick.*\\r\\n\\r\\n\\r\\nIn UMG, everything in the world is an entity.\\r\\nPlayers, bullets, enemies, trees, grass, are all entities.<br/>\\r\\nEntities exist on both the server and the client; however only the server\\r\\nhas the authority to create and delete them.\\r\\n\\r\\nA `Group` is like an array that holds entities. (<-- Remember this, it\'s important.)<br/>\\r\\nEntities are automatically added to groups if they have the required components for that group.\\r\\n\\r\\n```lua\\r\\n-- Here\'s a group with components  .x, .y  .image  \\r\\n-- All entities with these components are added to myGroup automatically.\\r\\nlocal myGroup = umg.group(\\"x\\", \\"y\\", \\"image\\")\\r\\n```\\r\\n\\r\\nOur \\"Systems\\" then will iterate over `group`s of entities,\\r\\nexecuting code and changing the state of entities as they go.\\r\\n\\r\\nSo, back to the example from before. With the ridable horses and elephants.\\r\\nWith our setup, we could have both horses and elephants contain a `ridable`\\r\\ncomponent, and have a system act on all entities with `x, y, ridable` components.\\r\\n\\r\\n```lua\\r\\nlocal ridableGroup = umg.group(\\"ridable\\", \\"x\\", \\"y\\")\\r\\n\\r\\nlocal function update()\\r\\n    for ent in ridableGroup do\\r\\n        local riderEnt = ent.rider\\r\\n        if riderEnt ~= nil then\\r\\n            -- set the rider\'s position to the steed ent.\\r\\n            riderEnt.x = ent.x\\r\\n            riderEnt.y = ent.y\\r\\n            riderEnt.z = ent.z + ent.ridable.rideHeight\\r\\n        end\\r\\n    end\\r\\nend\\r\\n\\r\\n-- Code for mounting.  This can be called by other mods, and is\\r\\n-- called automatically when the player clicks on the steed.\\r\\nlocal function mount(steedEnt, riderEnt)\\r\\n    if not ridableGroup:has(steedEnt) then\\r\\n        error(\\"this entity isn\'t ridable!\\")\\r\\n    end\\r\\n    steedEnt.rider = riderEnt\\r\\nend\\r\\n\\r\\n... -- more code here, etc\\r\\n```\\r\\n\\r\\nI\'d also like to point out that `riderEnt` does not neccessarily have to be a player.\\r\\nIn UMG, there\'s not really such thing as a \\"player\\"; a player is just a regular entity.<br/>\\r\\nWith this generic setup, we can have any entity type doing the riding. Which allows cool stuff such as:\\r\\n- Enemies on horses\\r\\n- Horses with chests on their back (chest entity is riding)\\r\\n- Horses with lights on their back (torch entity is riding)\\r\\n- Elephants with gun turrets on their back (turret entity is riding)\\r\\n\\r\\nBut anyway, that\'s getting sidetracked.<br/>\\r\\nThe main point of this is that now both the horse and the elephant can follow a\\r\\nstandard protocol for riding:\\r\\n```lua\\r\\n-- Horse entity\\r\\nreturn {\\r\\n  image = \\"horse\\",\\r\\n  ridable = {\\r\\n    rideHeight = 10\\r\\n  },\\r\\n  speed = 45\\r\\n}\\r\\n```\\r\\n\\r\\n```lua\\r\\n-- Elephant entity\\r\\nreturn {\\r\\n  image = \\"elephant\\",\\r\\n  ridable = {\\r\\n    rideHeight = 28\\r\\n  },\\r\\n  speed = 10\\r\\n}\\r\\n```\\r\\n\\r\\nAwesome!  Now, John and Mary\'s mods work together just fine. \\r\\n\\r\\n-------------\\r\\n\\r\\nUnfortunetely, Mary and John still have some problems that need to be addressed.\\r\\n\\r\\nIn John\'s horse riding mod, he wants to limit horse riding to the \\"knight\\" class.<br/>\\r\\nIn Mary\'s elephant riding mod, she wants the elephants to flap their ears when the player mounts.\\r\\n\\r\\nBut... how can this be solved?<br/>\\r\\nRemember, the `riding` mod is a *base mod.*\\r\\nWhich means it knows NOTHING about the current game context; all it cares about is the `ridable` component.\\r\\n\\r\\nSo, the `riding` mod knows NOTHING about elephant ears.<br/>\\r\\nIt also knows NOTHING about \\"knights\\" either. The concept of \\"knights\\" may not even exist, depending on what mods are loaded!\\r\\n\\r\\n## Mod communication through event buses:\\r\\n\\r\\nTo give Mary and John the tools to solve this problem, we can use [event-buses and question-buses.](../buses)\\r\\n\\r\\nSpecifically, John and Mary need two things:\\r\\n- Mary needs an event to be emitted whenever a ridable entity is mounted\\r\\n- John needs to signal to the `riding` mod that horses can\'t be mounted unless the entity is of knight class\\r\\n\\r\\nSo, lets update our `mount` function from before:\\r\\n```lua\\r\\n\\r\\nlocal function mount(steedEnt, riderEnt)\\r\\n    if not ridableGroup:has(steedEnt) then\\r\\n        error(\\"this entity isn\'t ridable!\\")\\r\\n    end\\r\\n\\r\\n    -- John needs to answer this question\\r\\n    if umg.ask(\\"ridingNotAllowed\\", OR, steedEnt, riderEnt) then\\r\\n        return -- not allowed!\\r\\n    end\\r\\n    \\r\\n    -- Mary needs this event\\r\\n    umg.call(\\"entityMounted\\", steedEnt, riderEnt)\\r\\n    steedEnt.rider = riderEnt\\r\\nend\\r\\n\\r\\n```\\r\\n\\r\\nNow, John and Mary can tag into these events, like so:\\r\\n```lua\\r\\n-- John\'s code:\\r\\numg.answer(\\"ridingNotAllowed\\", function(steedEnt, riderEnt)\\r\\n    if steedEnt.animalType == HORSE and riderEnt.class ~= KNIGHT then\\r\\n        return true\\r\\n    end\\r\\n    return false\\r\\nend)\\r\\n```\\r\\n\\r\\n```lua\\r\\n-- Mary\'s code:\\r\\numg.on(\\"entityMounted\\", function(steedEnt, riderEnt)\\r\\n    if steedEnt.animalType == ELEPHANT then\\r\\n        flapElephantEars(steedEnt)\\r\\n    end\\r\\nend)\\r\\n```\\r\\n\\r\\nVoila! Now, Mary and John can both have what they want, and\\r\\n*what\'s best*, is that their code is still 100% compatible.<br/>\\r\\nIsn\'t that beautiful?\\r\\n\\r\\nThis idea where mods are forced to be hyper-generic and hyper-compatible is a central goal of the UMG ecosystem.\\r\\n\\r\\nOther mods may also tag onto this stuff, and it will be 100% fine,\\r\\nsince the `ridable` mod doesn\'t care (and doesn\'t even know) what mods are listening\\r\\nto the events and answering the questions.\\r\\n\\r\\nFor example, maybe we want to have two teams, RED and BLUE.<br/>\\r\\nThis code makes it so only Blue team can use Blue horses, and same for Red:\\r\\n```lua\\r\\n-- Team system\\r\\numg.answer(\\"ridingNotAllowed\\", function(steedEnt, riderEnt)\\r\\n    if steedEnt.team and riderEnt.team and (steedEnt.team ~= riderEnt.team) then\\r\\n        -- not in same team! disallow riding.\\r\\n        return true\\r\\n    end\\r\\n    -- entities are either in same team, or don\'t have a team.\\r\\n    return false \\r\\nend)\\r\\n```\\r\\n\\r\\nWhat\'s great, is that this code is 100% compatible with John and Mary\'s code from before.\\r\\nIt\'s just *beautiful*.\\r\\n\\r\\n\\r\\n# Mod communication through components:\\r\\n\\r\\nEvents buses are not the only way mods can communicate.<br/>\\r\\nOften, communication is done by simply changing component values from within entities.\\r\\n\\r\\nHere\'s an example:\\r\\n\\r\\n--------------------\\r\\n\\r\\nLets say we want our mod to render entities:\\r\\n```lua\\r\\n-- rendering system\\r\\nlocal drawGroup = umg.group(\\"image\\", \\"x\\", \\"y\\")\\r\\n\\r\\nlocal function draw()\\r\\n    -- this draw function is called every frame\\r\\n    for ent in drawGroup do\\r\\n        graphics.draw(ent.image, ent.x, ent.y)\\r\\n    end\\r\\nend\\r\\n```\\r\\nIn this base mod, anything with an image, x, and y will be drawn to the screen.\\r\\n\\r\\nTo use this functionality, we can simply add the `x, y, image` components to one of our entities:\\r\\n```lua\\r\\nlocal ent = newEntity()\\r\\n\\r\\nent.x = 10\\r\\nent.y = 15\\r\\nent.image = \\"banana\\"\\r\\n```\\r\\nNow, this entity will be drawn to the screen automatically, at position (10, 15), with image \\"banana\\".\\r\\n\\r\\nAwesome!<br/>\\r\\nOkay, but what if we want an animation?\\r\\n\\r\\nTo handle animation, we can have another system that *changes* the `.image` component\\r\\nwith respect to time.<br/>\\r\\nFor example:\\r\\n```lua\\r\\n-- animation system\\r\\nlocal animationGroup = umg.group(\\"animation\\")\\r\\n\\r\\nlocal function update()\\r\\n    -- this function is called every frame\\r\\n    local time = getTime()\\r\\n    for ent in animationGroup do\\r\\n        ent.image = getAnimationImage(ent.animation, time)\\r\\n    end\\r\\nend\\r\\n```\\r\\n\\r\\nWhat\'s cool, is that this animation code and the rendering code from before\\r\\ncan be in entirely different systems, or even in *entirely different mods.*\\r\\n\\r\\nHere, the `animation` system is assuming that the rendering code will handle\\r\\nthe drawing of the entity, so all that it needs to care about is setting the image.\\r\\n\\r\\nIt\'s beautiful, right? :)\\r\\n\\r\\n\\r\\n# To conclude:\\r\\n\\r\\nThis document gives a brief overview of some design challenges (and solutions) that the UMG ecosystem has to deal with.\\r\\n\\r\\nI hope that the whole Base-mod / Playable-mod setup is a lot clearer, and I hope the\\r\\nreasoning behind it makes sense now.<br/>\\r\\nIt\'s certainly a challenging and interesting project, and I absolutely wish to see it through.\\r\\n\\r\\nThanks for reading.\\r\\n- Oli"},{"id":"buses","metadata":{"permalink":"/blog/buses","source":"@site/blog/2023-05-10_question_buses.md","title":"Question buses in UMG","description":"Question buses are a cool idea! This article will explain what they are.","date":"2023-05-10T00:00:00.000Z","formattedDate":"May 10, 2023","tags":[{"label":"design","permalink":"/blog/tags/design"},{"label":"umg","permalink":"/blog/tags/umg"}],"readingTime":5.025,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"buses","title":"Question buses in UMG","tags":["design","umg"]},"prevItem":{"title":"Technical implementation details for UMG","permalink":"/blog/umgtech"},"nextItem":{"title":"Emergence in games","permalink":"/blog/emergence"}},"content":"Question buses are a cool idea! This article will explain what they are.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n-------------------\\r\\n## PRELUDE: \\r\\n*This reading requires a basic understanding of my vision for Untitled Mod Game:*<br/>\\r\\nAll you need to know is that there are two types of mods, \\"Base mods\\",\\r\\nand \\"Playable mods.\\"\\r\\n\\r\\n- Base mods:\\r\\n    - provide tools and infrastructure for modders to create content\\r\\n    - do not provide any playable content\\r\\n\\r\\n- Playable mods:\\r\\n    - provide gameplay and content\\r\\n----------------------\\r\\n\\r\\n\\r\\n# Before we look at question buses, lets understand event buses.\\r\\n\\r\\nEvent bus diagram:\\r\\n\\r\\n![event_bus](images/event_bus.png)\\r\\n\\r\\nEvent buses are an *awesome* tool in the context of Untitled Mod Game.\\r\\n\\r\\nWhenever a significant action happens in a base mod, that base mod can simply\\r\\nemit an event to tell other mods that something interesting happened.\\r\\n\\r\\nWhat\'s beautiful, is that the base mod emitting the event doesn\'t care who\'s listening.\\r\\nIt just throws the event into the void; the systems that care about it will\\r\\ntag into it. Perhaps no one is listening! Perhaps 10 other mods are listening.\\r\\nThe base mod doesn\'t care.\\r\\n\\r\\nA good example of this is the `entityDeath` event.<br/>\\r\\nThis event is called automatically when an entity dies, and the entity is\\r\\npassed in as the first argument, like so:\\r\\n```lua\\r\\n-- base mod\\r\\numg.call(\\"entityDeath\\", ent)\\r\\n```\\r\\nIf other systems want to listen to this event, they can use `umg.on`:\\r\\n```lua\\r\\n-- Meanwhile, in a completely different mod:\\r\\numg.on(\\"entityDeath\\", function(ent)\\r\\n    -- plays a death sound when an entity dies.\\r\\n    if ent.deathSound then\\r\\n        playSound(ent.deathSound)\\r\\n    end\\r\\nend)\\r\\n```\\r\\n\\r\\nNow, this stuff is pretty basic, and this is nothing new. Event buses are a common\\r\\npattern, especially in game development.\\r\\n\\r\\nI could give examples of the entity emitting blood particles if it has the `meat` component,\\r\\nor spawning a full-health copy of itself if it has the `secondLife` component, but that\'s not the point\\r\\nof this post.\\r\\n\\r\\n\\r\\n# The problem space:\\r\\n\\r\\nOkay, so event buses are great for dispatching information when we are within an unknown context.\\r\\n\\r\\nBut sometimes we don\'t want to dispatch information.<br/>\\r\\nInstead, we may want to *receive* information.\\r\\n\\r\\nBehold, the holy *question bus*!!\\r\\n\\r\\n(I think it\'s best explained if I give a problem statement, and an example.)\\r\\n\\r\\nLets imagine that we have a system for attacking entities.<br/>\\r\\nThis system needs to know if an entity can attack or not.<br/>\\r\\nBut it doesn\'t know what other mods are loaded! It also doesn\'t know the context of the game\\r\\noutside of it\'s pure little abstract layer.\\r\\n\\r\\nSo, we turn to *question buses.*\\r\\n\\r\\n-----------------------\\r\\n\\r\\nWith question buses, we have two functions: \\r\\n```lua\\r\\n-- asks a question\\r\\numg.ask(question, reducer, ...)\\r\\n\\r\\n-- answers a question\\r\\numg.answer(question, answerFunc)\\r\\n```\\r\\n\\r\\n\\r\\n`ask` is similar to `call`, in that it initiates the \\"interaction\\".\\r\\n```lua\\r\\n-- attack system\\r\\nlocal reducer = operators.OR\\r\\n\\r\\nlocal isAttackBlocked = umg.ask(\\"isAttackBlocked\\", reducer, entity, targetEntity)\\r\\n```\\r\\n`reducer` is the reducer function; it reduces all the answers to one value\\r\\nby repeatedly applying itself to the answers.<br/>\\r\\n(By nature, the reducer needs to be associative and commutative,\\r\\nSo functions like `SUM` or `AND` would also work.)\\r\\n\\r\\n------------------------\\r\\n\\r\\n`answer` is similar to `on`, in that it responds to a question.<br/>\\r\\nInstead of executing something, however, the `answer` should ideally be a pure\\r\\nfunction that just returns a result. For example:\\r\\n```lua\\r\\n-- team handler system\\r\\n\\r\\numg.answer(\\"isAttackBlocked\\", function(entity, targetEntity)\\r\\n    if entity.team == targetEntity.team then\\r\\n        -- the entities are in the same team, so the attack should be blocked.\\r\\n        return true\\r\\n    end\\r\\n    return false\\r\\nend)\\r\\n```\\r\\n\\r\\nWe may also have another answer, e.g. inside the stun system:\\r\\n```lua\\r\\numg.answer(\\"isAttackBlocked\\", function(entity, targetEntity)\\r\\n    if entity.stunned then\\r\\n        -- entity is stunned, and cannot attack\\r\\n        return true \\r\\n    end\\r\\n    return false\\r\\nend)\\r\\n```\\r\\n\\r\\nIf either of these \\"answerers\\" return true, then the attack is blocked.\\r\\n\\r\\n-----------------\\r\\n\\r\\nHere\'s an image that hopefully clarifies the idea further:\\r\\n\\r\\n![question_bus](images/question_bus.png)\\r\\n\\r\\n-----------------\\r\\n\\r\\nAll in all, the pattern can be summarized simply as so:\\r\\n\\r\\n- Regular event buses:\\r\\n    - Dispatch information in an abstract manner\\r\\n    - Doesn\'t care who is listening\\r\\n\\r\\n- Question buses:\\r\\n    - Gather information in an abstract manner\\r\\n    - Doesn\'t care who gives the information\\r\\n\\r\\n------------------\\r\\n\\r\\nNow, just quickly, I want to recap on why this pattern is actually useful.\\r\\n*Why wouldn\'t you just check if the entities are on the same team in the `attack` code, instead of asking?*\\r\\n\\r\\nWith this setup, the `attack` system doesn\'t *know* about the concept of teams.\\r\\nIn fact, the concept of \\"teams\\" may not even exist, depending on what mods are loaded!\\r\\n\\r\\nThe attack system is asking a question in an abstract manner, and getting different results\\r\\ndepending on the what mods are loaded.\\r\\n\\r\\nThis is the exact same thing as event buses, except we are receiving information instead\\r\\nof dispatching information.\\r\\n\\r\\n# Is this pattern useful enough to justify it\'s existance?\\r\\n\\r\\nIt\'s pretty obvious just from looking at this pattern to see how easily\\r\\nit could be abused.<br/>\\r\\nIt\'s the same as normal event buses; powerful, yet easy to abuse.\\r\\n\\r\\nSo, given the abuse potential, is this pattern worth it?\\r\\n\\r\\n**Yes**, I would say so.<br/>\\r\\nPerhaps this pattern is not useful in other problem spaces, but in UMG where we\\r\\nliterally **NEED** a way to receive information unassumingly, question buses just... *chefs kiss.*\\r\\n\\r\\nTo demonstrate why, here are some other questions that could be asked:\\r\\n```lua\\r\\numg.ask(\\"canOpenInventory\\", OR, inventory, ent) -- whether an inventory can be opened by `ent`\\r\\numg.ask(\\"isHidden\\", OR, ent) -- whether `ent` is hidden\\r\\numg.ask(\\"canUseItem\\", OR ent, itemEnt) -- whether `ent` can use `itemEnt`\\r\\numg.ask(\\"canRide\\", OR, ent, steedEnt) -- whether `ent` can ride `steedEnt`\\r\\n\\r\\n-- a more interesting one:\\r\\numg.ask(\\"getDamageMultiplier\\", MULTIPLICATION, ent, targetEnt)\\r\\n-- returns the damage multiplier for `ent`.\\r\\n-- Note that the reducer function is multiplication in this case.\\r\\n-- This is because we are combining the damage multipliers from all answers.\\r\\n```\\r\\n\\r\\n\\r\\n# To conclude:\\r\\nquestion buses are a cool concept! :)\\r\\n\\r\\nAlthough they can probably be abused very easily, (same as event buses,)\\r\\nthey still provide a very useful pattern for my project.\\r\\n\\r\\nThanks for reading this opinion piece! I hope I opened your mind a bit.\\r\\n\\r\\n- Oli"},{"id":"emergence","metadata":{"permalink":"/blog/emergence","source":"@site/blog/2023-04-28_emergence.md","title":"Emergence in games","description":"Emergence is not needed for a good game. And we know this, because there are","date":"2023-04-28T00:00:00.000Z","formattedDate":"April 28, 2023","tags":[{"label":"gamedesign","permalink":"/blog/tags/gamedesign"},{"label":"opinion","permalink":"/blog/tags/opinion"}],"readingTime":14.235,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"emergence","title":"Emergence in games","tags":["gamedesign","opinion"]},"prevItem":{"title":"Question buses in UMG","permalink":"/blog/buses"}},"content":"Emergence is not needed for a good game. And we know this, because there are\\r\\nplenty of successful games out there that are non-emergent. \\r\\n(Some examples being: Super Meat Boy, the whole Call of Duty franchise, Mario Kart)\\r\\n\\r\\nBut as an indie developer, we are in a field where we **NEED** to put ourselves ahead by taking risks.\\r\\nIf we don\'t, we will be outcompeted by others similar to us.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nEmergence offers us a way to create way more gameplay opportunities, for very little cost.\\r\\nAs an indie dev, creating extra gameplay without needing to expend vast amounts of resources\\r\\nis very useful.\\r\\n\\r\\nBut... what *IS* Emergence in a game context?<br/>\\r\\nEmergence itself is quite hard to define! \\r\\n\\r\\nSo in this blog post, I\'ll examine a few examples of good emergence from existing games,\\r\\nand cherry pick what I think is the good stuff.\\r\\n\\r\\nKeep in mind, this is all just my opinion!\\r\\n\\r\\nBefore we dive into it, though; we need to do some housekeeping.\\r\\n\\r\\n--------------------------\\r\\n\\r\\n## Lets discuss the golden rule:\\r\\nChess is a highly-emergent game.<br/>\\r\\nBecause of this, it has existed for thousands of years, and is one of the most popular\\r\\ngames played by people to this date.\\r\\n\\r\\n![chess](images/chess.jpg)\\r\\n\\r\\nBut chess on its own is not very interesting.<br/>\\r\\nImagine if you were playing 1-player chess, where you just moved the pieces around.\\r\\nWould that be very fun? (No, it\'s not fun. And I know it\'s not fun, because nobody does it.)<br/>\\r\\nI\'m using this example, because I want to clarify something important, which I call\\r\\n\\"The golden rule\\":\\r\\n\\r\\n- *Emergence on its own won\'t cut it. You need Emergence, combined with the human mind.*\\r\\n\\r\\nSuddenly, if you have another player on the other side of the board,\\r\\nplotting their moves, and attempting to discover your tactics,\\r\\nyou have a very interesting and complex game.\\r\\n\\r\\nTo put it elegantly, emergence in games is not about creating \\"cooler\\" or \\"better\\" rules;\\r\\nrather, it\'s about allowing the player to create their own gameplay THROUGH the rules.[^1]\\r\\n\\r\\nWhen chess was first created, I can almost guarantee that the Fried-Liver attack did not exist.\\r\\nHumans created this gameplay element, *using* the emergent ruleset of chess.\\r\\n\\r\\n--------------------------\\r\\n\\r\\nNow, chess is a simple example that\'s easy to grasp, but also a very basic, and awkward example.\\r\\nSince a lot of the gameplay is not actually created by the player, but rather, by the opponent.\\r\\n\\r\\nSo lets look at another game that allows its players to create gameplay value, \\r\\nwithout the need for an opponent:\\r\\n\\r\\n## *Minecraft.*\\r\\n\\r\\nMinecraft is a ground-breaking, brilliant game.\\r\\nBefore minecraft, there was no real sandbox game available to the casual gamer.\\r\\n\\r\\nIt was so ahead of its time, and its success kinda speaks for itself.\\r\\n\\r\\nWhat I\'d like to look at though, is its emergent game rules.\\r\\nNow, there are 2 distinct examples that I want to pick apart here;\\r\\nlets not get lost in the weeds though. The two distinct examples are:\\r\\n\\r\\n- Emergence in building\\r\\n- Emergence in engineering\\r\\n\\r\\n## Minecraft- Emergence in building:\\r\\nIn minecraft, many players just want to build cool shit.\\r\\nI\'d argue that *most* players want to do this, actually.\\r\\n\\r\\n- Take a look at this image:\\r\\n\\r\\n![minecraft](images/minecraft.jpg)\\r\\n\\r\\nTo a minecraft player, this will look quite normal.\\r\\nIt\'s a little cottage, with a cute little wooden roof and windows. <br/>\\r\\nOn the right are some nice stair blocks leading to a deck.\\r\\n\\r\\nBut lets slow down a bit; take a look at the sloped roof.\\r\\nOn the roof of the house are ALSO stair blocks, lined up to produce a nice slope.\\r\\n\\r\\nIn Minecraft, the same blocks can be used in different ways to allow the builder \\r\\nto express their creativity to a higher degree.\\r\\n\\r\\nLook again, at the windows, and the door. Stairs are being used AGAIN,\\r\\nthis time, to provide some depth to the walls, and to provide a rounded entrance.\\r\\nRemember: stairs are just one block type. Players only need to remember one recipe to\\r\\ncreate all this wonderful stuff. Isn\'t that brilliant? \\r\\n\\r\\nOne block on its own does not do anything interesting, but multiple blocks\\r\\ntogether, *combined* with the human mind, allows the player to create gameplay\\r\\nopportunities for themselves.[^1]\\r\\n\\r\\n\\r\\n## Minecraft- Emergence in engineering:\\r\\n\\r\\nThis is a more interesting aspect, but it also gives way to a more important concept that I\\r\\nwant to talk about: ***Simplicity.***\\r\\n\\r\\nIf you are a minecraft player, you have probably seen those videos of huge industrial\\r\\nmob farms that automatically farm resources for you.\\r\\n\\r\\n(If you haven\'t, quickly google \\"efficient iron farm\\" on youtube, you\'ll see a bunch of unique designs)\\r\\n\\r\\nFor a second though, lets stop to ponder. Did the developers of minecraft intend for there\\r\\nto be massive, industrial item-farms?\\r\\nMaybe! But whatever the case, they *definitely* did not conceive the designs.\\r\\n\\r\\nI\'ll run briefly how a basic mob-farm may work, by breaking down the systems:\\r\\n- Water pushes entities in its flow direction\\r\\n- Mob entities spawn in the dark\\r\\n- Mob entities drop item entities on death\\r\\n- Entities with health take damage if they fall a big distance\\r\\n\\r\\nWith these rules, players can create a chamber that automatically spawns mobs,\\r\\npushes them to a cliff, kills the mobs, and transports the dropped items to a safe collection point.\\r\\n\\r\\n(Also note that these rules are all independent of one another.\\r\\nAny one of these rules may be used in another context independently to produce gameplay.)\\r\\n\\r\\nThese farms are not created because the minecraft devs wanted you to create them.\\r\\nThey are created because the players have a goal: \\"Get resources\\".\\r\\nAnd with this goal, the players can bend the world to their will, because the rules are emergent enough\\r\\nto allow it.\\r\\n\\r\\nBut, we are missing something important. The vast majority of players won\'t build these giant,\\r\\ncomplex, intricately engineered item farms.\\r\\n\\r\\nWhy not?\\r\\n\\r\\nIn my opinion, it all comes down to *simplicity.*<br/>\\r\\nIf the rules become too difficult to apply in a creative manner, then\\r\\na bunch of players are cut off. (either because they aren\'t patient enough, or they aren\'t willing\\r\\nto invest a lot of mental energy in the game.)\\r\\nThese massive, industrial farms are not simple to make; they require quite a deep understanding\\r\\nof the game systems, and they definitely require a lot of human creativity.\\r\\n\\r\\nRemember the golden rule: \\r\\n- *Emergence on its own won\'t cut it. You need Emergence, combined with the human mind.*\\r\\n\\r\\nPlayers that aren\'t engaged enough to invest a bunch of time and energy\\r\\nwill fail to create these gameplay opportunities.[^1]\\r\\n\\r\\nTo sum it up, it\'s not about how *simple* the rules are; rather, it\'s about how\\r\\n*simply the player can work with them.*\\r\\n\\r\\n\\r\\n## Is Minecraft cheating?\\r\\n\\r\\nOkay, we get it. Minecraft is a brilliant game.<br/> \\r\\nAnd its success shows it.\\r\\n\\r\\nBut doesn\'t it cheat? Minecraft is a sandbox game; of course its going to be highly emergent\\r\\nwhen the player can literally alter the world.\\r\\n\\r\\nYes, that\'s true; sandbox games *are* naturally emergent.\\r\\nBut Minecraft still does it the best, IMO.<br/>\\r\\nThere are many minecraft-like games that have been no-where near as successful,\\r\\nbecause they don\'t provide the player with emergent gameplay opportunities like minecraft does.\\r\\n\\r\\nA few examples of this are:\\r\\n- Eden\\r\\n- Trove\\r\\n- Eco\\r\\n\\r\\nI\'ve hardly been able to find any \\"automatic farm\\" designs for any of these games;\\r\\n(Or at least, no designs that are out of scope of what the developer intended.)\\r\\n\\r\\nPretty much all existing designs for stuff lay within the developer\'s closed vision for gameplay,\\r\\nwhich is a sign of insufficient emergence.\\r\\n\\r\\n-------------\\r\\n\\r\\nOkay, cool.\\r\\n\\r\\nSo what\'s an example of emergent gameplay that\'s NOT within a sandbox context?\\r\\n\\r\\n## Emergence in the Binding of Isaac\\r\\n\\r\\n![isaac](images/isaac.jpg)\\r\\n\\r\\nYup yup, it\'s this game.\\r\\nIf you play roguelikes, you probably saw this from a mile away.\\r\\n\\r\\nThe Binding of Isaac has seen years and years of praise, and is (arguably) the\\r\\nmost successful indie roguelike ever.\\r\\n\\r\\nBut to understand what makes Isaac fun, we need quickly understand the core game:\\r\\n\\r\\n- Player starts a run with randomly generated levels\\r\\n- Player fights her way through levels, achieving upgrades and items\\r\\n- Player either dies, or beats the game in less than 40 minutes\\r\\n- (Repeat, ad infinitum)\\r\\n\\r\\nA lot of the \\"fun\\" in Isaac comes from the player\'s ability to obtain synergies\\r\\nbetween items, and make an interesting/powerful combo.\\r\\n\\r\\nBut how are synergies done? There are hundreds (if not thousands) of roguelikes on the\\r\\nmarket that have synergies between items.<br/>\\r\\nWhat does Isaac do that\'s special?\\r\\n\\r\\n-------------\\r\\n\\r\\nLets create two imaginary items, `Item X` and `Item Y`.\\r\\n\\r\\nNow lets assume that items X, Y apply some effect to the player.\\r\\nIn this example, it doesn\'t matter too much what they actually do;\\r\\njust know that they do *something*.\\r\\n\\r\\nAs a game designer, we might want to add a synergy between `X` and `Y`.\\r\\nSo, lets hardcode a little rule:\\r\\n```c\\r\\nItem X synergizes with Item Y, by granting 10 attack damage\\r\\n```\\r\\n\\r\\nBut this is terrible.<br/>\\r\\nWhy? Why is this terrible?\\r\\n\\r\\nThis is terrible, because it\'s a very closed, non-emergent ruleset.<br/>\\r\\nIf another item comes along, (i.e. `Item Z`) it will never be able to mesh\\r\\ncreatively with the existing synergy between `X` and `Y`.\\r\\n\\r\\nIt would be much better to have a system that tags into mechanics instead.\\r\\nLets imagine we have a game mechanic \\"M\\".\\r\\nOur setup could look like:\\r\\n```c\\r\\nItem X: provides \\"M\\"\\r\\nItem Y: adds attack damage equal to \\"M\\"\\r\\n```\\r\\n\\r\\nSuddenly, we have a more interesting ruleset on our hands, that provides\\r\\nthe *exact same* synergy.\\r\\n\\r\\n*Why is this better, though?*<br/>\\r\\nWell, if we create another item, `Item Z`, we can mesh `Z` with the existing\\r\\nmechanic `M`:\\r\\n```c\\r\\nItem Z: doubles \\"M\\" when the player is on low health.\\r\\n```\\r\\n\\r\\nSuddenly, we have potential for a synergy between `Item Z`, and `Item Y` for free. Isn\'t that brilliant?<br/>\\r\\nIt cost us *NOTHING* to do this, we literally gained gameplay for free.<br/>\\r\\nNot only this, but any other item that meshes with the existing mechanic \\"M\\" will either be a synergy/anti-synergy to `Item Z` and `Item Y`.\\r\\n\\r\\nThe Binding of Isaac does this kind of thing really *really* well,\\r\\nby having virtually all passive items tag into game mechanics and mesh with\\r\\nother items by proxy.\\r\\n\\r\\nHere are some examples.<br/>\\r\\nI have listed the mechanic (`M`) that it tags into, too.\\r\\n\\r\\n```\\r\\n- Host hat: immune to explosion damage\\r\\n- Kamikaze: creates a damaging explosion next to the player\\r\\n- Glitter bombs: Your explosions spawn pickups\\r\\n- MECHANIC: Explosions\\r\\n```\\r\\nThis synergy gives infinite pickups, free explosions, and a tonne of damage.\\r\\n\\r\\n```\\r\\n- Brimstone:  Replaces tears with a slow, massive damaging lazer beam\\r\\n- Tammys head:  releases a burst of whatever tear type is active\\r\\n- MECHANIC: Fire rate / tear type\\r\\n```\\r\\n\\r\\n```\\r\\n- Lump of coal:  Shots deal extra damage based on distance travelled\\r\\n- Tiny planet:  Shots orbit, travelling for way longer\\r\\n- MECHANIC: Shot range / shot trajectory\\r\\n```\\r\\n\\r\\nEach of these examples provides a cool synergy that is good for the player.\\r\\n\\r\\nWhat\'s important, is that none of these items directly interact with each other.\\r\\nRather, the items mesh with *an existing mechanic*;\\r\\na mechanic that may affect (or be affected) by any other item in the game.\\r\\n\\r\\n\\r\\n## Emergence as a natural phenomenon\\r\\n\\r\\nSometimes, instead of programming game rules directly, it might be best\\r\\nto work backwards.\\r\\n\\r\\nTake a mental note of the intended behaviour,\\r\\nand develop natural rules to produce that behaviour in the game.\\r\\n\\r\\nFor example, instead of doing this:\\r\\n```\\r\\nwhen bullet entity collides ---\x3e deal damage\\r\\n```\\r\\n\\r\\nYou could do this:\\r\\n```\\r\\nFast moving, sharp entities ---\x3e Deal damage\\r\\nBullets ---\x3e Are fast and sharp (so deal damage)\\r\\n```\\r\\n\\r\\nNote that this is also how the real world works.<br/>\\r\\nThe real world doesn\'t care if something is a \\"bullet\\", or a \\"train\\".\\r\\nIf you get hit by either one at great speeds, you will probably die.\\r\\n\\r\\nSo the best way to describe this kind of idea, is representing the game\\r\\nin a more natural format.\\r\\n\\r\\nThis is both a bad idea, and a good idea.\\r\\n\\r\\n-----------------\\r\\n\\r\\n- *Why is natural emergence a good idea?*\\r\\n\\r\\nWell, in future, players might be able to come up with creative damage devices.\\r\\nSuch as custom mechanical cannons, or lining up shrapnel near\\r\\nexplosives to kill enemies.\\r\\n\\r\\nIt opens the game rules, and allows players to think outside of the developer\'s\\r\\nbox. Remember; it\'s all about allowing the player to create their own gameplay.[^1]\\r\\nIf we provide natural, emergent rules, this is much more viable.\\r\\n\\r\\n\\r\\n- *Why is natural emergence a bad idea?*\\r\\nLets talk about what I call the \\"Friendly-Fire dilemma\\".\\r\\n\\r\\n#### The Friendly-Fire dilemma\\r\\n\\r\\nEmergent systems are not without costs;<br/>\\r\\nThe biggest cost of an emergent game system is the loss of developer control.\\r\\n\\r\\nLets recap on our example from before.\\r\\n```\\r\\nFast moving, sharp entities ---\x3e Deal damage\\r\\nBullets ---\x3e Are fast and sharp (so deal damage)\\r\\n```\\r\\n\\r\\nNow, lets create a quick example that could be seen in game:\\r\\n```\\r\\nFast moving, sharp entities ---\x3e Deal damage\\r\\nBullets ---\x3e Are fast and sharp (so deal damage)\\r\\n\\r\\nPlayers shoot bullet at zombie, miss and hit friend --\x3e Player kills friend!\\r\\n```\\r\\n\\r\\nSuddenly, we have a situation where players can accidentally shoot\\r\\nand kill their friends, which, (at face value,) is bad.\\r\\n\\r\\nI call this the \\"Friendly Fire dilemma\\".\\r\\n\\r\\nTo put it frankly, this is the cost that we pay for emergent systems.\\r\\nSometimes our rules will have unintended consequences that we cannot solve without\\r\\nfudging with the rules in an unnatural, non-emergent fashion.[^2]\\r\\n\\r\\nThankfully, these issues aren\'t a big deal generally; as players will actively work\\r\\n*WITH* the rules to achieve their goal, not against them.<br/>\\r\\nIf shooting team-members hurts the chances of meeting a goal,\\r\\nplayers probably won\'t do it.\\r\\n\\r\\nHere\'s a little impromptu equation that describes the whole idea quite nicely:\\r\\n\\r\\n```\\r\\nEmergence * DeveloperControl  =  CONSTANT\\r\\n```\\r\\n\\r\\nWith every unit of emergence we add, *by nature*, we lose control as a developer.\\r\\n\\r\\nSimilar to how John Conway couldn\'t control the shape of Gosper\'s Glider gun,\\r\\nand similar to how the creators of Chess couldn\'t control how the Sicilian defence worked,\\r\\nas a developer, you lose control of your game when you create emergent rulesets.\\r\\n\\r\\nNote that this isn\'t neccessarily a \\"bad\\" thing.<br/>\\r\\nWith chess, the Sicilian defence does not hurt chess\'s integrity; it\'s just part of the game.\\r\\n\\r\\nMainly, the loss of developer control is just something to keep in mind :^)\\r\\n\\r\\n\\r\\n----------------\\r\\n\\r\\n\\r\\n## Emergence in Super Auto Pets\\r\\n\\r\\nThis blog post is getting quite long, but this is still a really good example that I want to cover.\\r\\nThankfully, someone else has already done a pretty good analysis on SAP\'s mechanics that sums up some of my thoughts.\\r\\n\\r\\nSo instead of doing my own analysis, I am instead going to link that blog post:\\r\\n[Have a read if you are extra interested.](https://a327ex.com/posts/super_auto_pets_mechanics)\\r\\n\\r\\nOne significant takeaway is that unit abilities don\'t operate in a closed fashion.\\r\\nSimilar to Isaac, abilities mesh with each other in an abstract fashion, which allows players to reason about the\\r\\ngame creatively and come up with their own strategies.\\r\\n\\r\\nSAP is also a pretty neat example, since it completely NAILS the simplicity aspect that was\\r\\ntalked about before.\\r\\n\\r\\n\\r\\n# TO CONCLUDE:\\r\\n\\r\\nIt\'s not about creating \\"more interesting\\" gameplay, or providing\\r\\na \\"more in-depth\\" experience for the player.\\r\\n\\r\\nRather, it\'s about providing the player with sufficiently emergent rules, such that they can\\r\\ncreate their OWN gameplay.\\r\\n\\r\\n- *Emergence on its own won\'t cut it. You need Emergence, combined with the human mind.*\\r\\n\\r\\nThanks for reading this opinion piece!\\r\\n\\r\\n- Oli\\r\\n\\r\\n\\r\\n----------------\\r\\n\\r\\n[^1]: When I say that a player \\"Creates gameplay\\", I mean that the player executes actions, sets goals, or interacts with the game world in a way that the developer did not directly specify. For example, a chess player executing a discovered attack with their knight. The creators of chess did not \\"create\\" this mechanic, this mechanic was instead \\"created\\" by the players.\\r\\n\\r\\n[^2]: YES, we *could* easily hardcode it so that bullets shot by a player don\'t harm players. But this kinda goes against the point of emergent rulesets in the first place. The whole point of an emergent ruleset is so that the players can mesh with the rules in a creative fashion! If we put in restrictions like this, we are closing corridors of opportunity. This situation where players can harm their allies? This can also be a GOOD situation, if you look at it a bit differently. Suddenly, friendly-fire is now a mechanic of the game; a mechanic that must be taken into account when approaching levels/situations. Also, fudging with the rules in this fashion is highly unintuitive from a player PoV. Why do my bullets not deal damage to my buddies, but crashing a car into my buddies does deal damage? If we want the player to understand our rules intuitively, fudging with rules like this is a bad idea."}]}')}}]);