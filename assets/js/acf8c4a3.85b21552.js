"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4944],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var r=o.createContext({}),p=function(e){var t=o.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=p(e.components);return o.createElement(r.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},c=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,r=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=p(n),c=i,h=d["".concat(r,".").concat(c)]||d[c]||u[c]||a;return n?o.createElement(h,s(s({ref:t},m),{},{components:n})):o.createElement(h,s({ref:t},m))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,s=new Array(a);s[0]=c;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l[d]="string"==typeof e?e:i,s[1]=l;for(var p=2;p<a;p++)s[p]=n[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}c.displayName="MDXCreateElement"},8158:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var o=n(7462),i=(n(7294),n(3905));const a={slug:"umg_decoupling",title:"Avoiding refactoring, and aggressive decoupling",tags:["design","coding","umg"]},s=void 0,l={permalink:"/blog/umg_decoupling",source:"@site/blog/2024-04-13_umg_decoupling.md",title:"Avoiding refactoring, and aggressive decoupling",description:"(Rambling and ideas about UMG decoupling, and avoiding future refactors)",date:"2024-04-13T00:00:00.000Z",formattedDate:"April 13, 2024",tags:[{label:"design",permalink:"/blog/tags/design"},{label:"coding",permalink:"/blog/tags/coding"},{label:"umg",permalink:"/blog/tags/umg"}],readingTime:4.035,hasTruncateMarker:!0,authors:[],frontMatter:{slug:"umg_decoupling",title:"Avoiding refactoring, and aggressive decoupling",tags:["design","coding","umg"]},prevItem:{title:"Terminology for UMG",permalink:"/blog/umg_terminology"},nextItem:{title:"The Art of Assumptions",permalink:"/blog/art_of_assumptions"}},r={authorsImageUrls:[]},p=[{value:"Warning!! This post is quite &quot;rambly&quot;.",id:"warning-this-post-is-quite-rambly",level:3},{value:"Overall, his ideas are summed up as so:",id:"overall-his-ideas-are-summed-up-as-so",level:2},{value:"Downside of decoupling of components:",id:"downside-of-decoupling-of-components",level:3},{value:"Let the playable-mods define the components.",id:"let-the-playable-mods-define-the-components",level:2},{value:"Mods without components:",id:"mods-without-components",level:2}],m={toc:p},d="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"(Rambling and ideas about UMG decoupling, and avoiding future refactors)"),(0,i.kt)("h3",{id:"warning-this-post-is-quite-rambly"},'Warning!! This post is quite "rambly".'),(0,i.kt)("hr",null),(0,i.kt)("p",null,"I had a ",(0,i.kt)("em",{parentName:"p"},"very")," interesting conversation with someone in the Love2d discord surrounding decoupling of ECS components."),(0,i.kt)("p",null,'His opinion was that components should be "aggressively decoupled." ',(0,i.kt)("br",null),"\nFor example; components that work with a position, should store their ",(0,i.kt)("strong",{parentName:"p"},"OWN")," position.",(0,i.kt)("br",{parentName:"p"}),"\n","EG:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sprite")," component should OWN a render-position vector"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"physics")," component should OWN a world-position vector")),(0,i.kt)("p",null,'The idea then, was that an external component would come along, and "glue" them together, to make positioning consistent.'),(0,i.kt)("p",null,"The reason this is nice, is because if we want to do some fudging-around with the sprite's rendering position, (eg, make images bob up and down,) then that is easily doable; since the sprite component's position is not coupled to anything.",(0,i.kt)("br",{parentName:"p"}),"\n","This was a really interesting perspective to hear, and I think it opened my mind a lot."),(0,i.kt)("p",null,"Now admittedly, I dislike this specific example; for two reasons:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It makes stuff more complicated"),(0,i.kt)("li",{parentName:"ul"},"There's no longer a single-source of truth for position")),(0,i.kt)("p",null,"Also, in UMG, we can use question-buses within the rendering system to augment the rendering position in a stateless manner; so some of the nasty effects of ",(0,i.kt)("inlineCode",{parentName:"p"},"image-position")," coupling are at least mitigated."),(0,i.kt)("p",null,"But it was still very interesting !",(0,i.kt)("br",{parentName:"p"}),"\n","And in general, I think that these ",(0,i.kt)("em",{parentName:"p"},"ideas")," are still very useful."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"overall-his-ideas-are-summed-up-as-so"},"Overall, his ideas are summed up as so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Always prefer decoupling, if possible.\nGlue-code is ALWAYS better than overly-coupled systems.\n\nIssues with high-coupling:\n- hard to extend, manage, very restrictive.\n\nIssues with glue-code:\n- Forgetting to add the glue. OOPSIE! (No problem)\n\n")),(0,i.kt)("p",null,"(Obviously, the issues of glue-code are WAY less significant than the issues of a overly-coupled system.)"),(0,i.kt)("h3",{id:"downside-of-decoupling-of-components"},"Downside of decoupling of components:"),(0,i.kt)("p",null,"Now, one BIG downside with glue-code, (and aggressive-decoupling,) is that it often generates multiple sources of truth.",(0,i.kt)("br",{parentName:"p"}),"\n","This is kinda just the price we pay."),(0,i.kt)("hr",null),(0,i.kt)("h1",{id:"example-of-good-decoupling-in-umg"},"Example of good-decoupling in UMG:"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"items")," mod, with the ",(0,i.kt)("inlineCode",{parentName:"p"},"effects")," mod.\nTake the high-level concept: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'"When player equips helmet, helmet gives +2 armor."')),(0,i.kt)("p",null,"And the ",(0,i.kt)("inlineCode",{parentName:"p"},"helmet")," entity is represented as an item:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'defineItem({\n    propertyEffect = {\n        armor = 2\n    },\n    name = "Steel Helmet",\n    ...\n})\n')),(0,i.kt)("p",null,"Internally, entities have a list of effects:   "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ent.effects = Effects(...)"),(0,i.kt)("br",{parentName:"li"}),"And entities can also have an inventory: "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ent.inventory = Inventory(...)"))),(0,i.kt)("p",null,"We would implement this in UMG like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'\n--[[\n    Integration with items mod:\n\n    :onItemAdded is called when itemEnt is added to this slot.\n    :onItemRemoved is called when itemEnt is removed from this slot.\n    :canAddItem checks whether we can add the item.\n]]\nlocal HelmetSlot = objects.Class("...")\n    :implement(items.SlotHandle)\n\nfunction HelmetSlot:onItemAdded(itemEnt)\n    local ent = self:getOwner()\n    if ent.effects then\n        ent.effects:add(ent, itemEnt)\n    end\nend\n\nfunction HelmetSlot:onItemRemoved(itemEnt)\n    local ent = self:getOwner()\n    if ent.effects then\n        ent.effects:remove(itemEnt)\n    end\nend\n\nfunction HelmetSlot:canAddItem(itemEnt)\n    return isHelmet(itemEnt)\nend\n\n')),(0,i.kt)("br",null),(0,i.kt)("p",null,"Then, inside the inventory;"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'\nlocal PlayerInventory = objects.Class("...")\n    :implement(items.Inventory)\n\nfunction PlayerInventory:init()\n    self:setSlotHandle(1, HelmetSlot())\nend\n')),(0,i.kt)("h1",{id:"history-of-umg"},"History of UMG:"),(0,i.kt)("p",null,"Throughout UMG's history, (across the past couple of years,) we have ",(0,i.kt)("em",{parentName:"p"},"CONSISTENTLY")," created WAY TOO MANY bloaty components."),(0,i.kt)("p",null,"A good example of this is ",(0,i.kt)("inlineCode",{parentName:"p"},"basicUIComponent"),", deployed by the ",(0,i.kt)("inlineCode",{parentName:"p"},"ui.basics")," mod.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"basicUIComponent")," is very ",(0,i.kt)("em",{parentName:"p"},"meh"),", and some other components within ",(0,i.kt)("inlineCode",{parentName:"p"},"ui.basics")," are kinda bad too. These components are tightly coupled to the system that they operate in, which is bad."),(0,i.kt)("p",null,"As such, I'm suggesting a new philosophy:"),(0,i.kt)("h2",{id:"let-the-playable-mods-define-the-components"},"Let the playable-mods define the components."),(0,i.kt)("h1",{id:"not-the-base-mods"},"NOT the base-mods!!!"),(0,i.kt)("h1",{id:"base-mods-should-be-assumptionless-and-pure"},"Base mods should be assumptionless, and pure."),(0,i.kt)("p",null,"It's okay if quick and dirty/hacky components are in playable mods.",(0,i.kt)("br",{parentName:"p"}),"\n","But it is NOT OKAY if dirty/hacky components are in ",(0,i.kt)("strong",{parentName:"p"},"base")," mods."),(0,i.kt)("p",null,"On a related note, I think that we should try to ",(0,i.kt)("em",{parentName:"p"},"minimize")," our usage of component-projection.",(0,i.kt)("br",{parentName:"p"}),"\n","comp-projection shares the exact same issues that inheritance has; in that it creates, deep, wide, invisible hierarchies that are kindof hard to understand."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"mods-without-components"},"Mods without components:"),(0,i.kt)("p",null,"We should attempt to have mods/systems like ",(0,i.kt)("inlineCode",{parentName:"p"},"typecheck"),"; a mod that defines NO components.\nOr, a mod like ",(0,i.kt)("inlineCode",{parentName:"p"},"generation"),"; which also defines NO components; yet is extremely powerful and useful."),(0,i.kt)("p",null,"Instead of creating many components; focus on creating small, generic components, with ",(0,i.kt)("em",{parentName:"p"},"powerful")," systems to go alongside them."),(0,i.kt)("h1",{id:"component-design-ethos"},"Component design ethos:"),(0,i.kt)("p",null,"Lets sum everything up:   "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Keep components small, simple, and meaningful. Components should be small and few; but the systems behind them should be powerful.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Decoupling of components is good. Glue code is better than implicit coupling, (within reason); even if it generates multiple sources of truth.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'Its OK to define "hacky/bloaty" components in Playable mods and Addons. But not in Base mods; base-mods ',(0,i.kt)("em",{parentName:"p"},"must")," remain clean.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Avoid multi layered component projection in base mods, if possible; (with the obvious exception being flag-components, since they are single layered). Playable/addon mods can have hacky, large spanning projections, since cleanliness doesnt matter as much."))))}u.isMDXComponent=!0}}]);