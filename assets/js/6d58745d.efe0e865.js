"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1067],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),h=p(n),c=r,d=h["".concat(l,".").concat(c)]||h[c]||u[c]||o;return n?a.createElement(d,i(i({ref:t},m),{},{components:n})):a.createElement(d,i({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},8652:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={slug:"art_of_assumptions",title:"The Art of Assumptions",tags:["design","coding"]},i=void 0,s={permalink:"/blog/art_of_assumptions",source:"@site/blog/2024-03-27_assumptions.md",title:"The Art of Assumptions",description:"I am writing this post, because I don't want to make mistakes like this in the future.",date:"2024-03-27T00:00:00.000Z",formattedDate:"March 27, 2024",tags:[{label:"design",permalink:"/blog/tags/design"},{label:"coding",permalink:"/blog/tags/coding"}],readingTime:4.85,hasTruncateMarker:!0,authors:[],frontMatter:{slug:"art_of_assumptions",title:"The Art of Assumptions",tags:["design","coding"]},prevItem:{title:"Avoiding refactoring, and aggressive decoupling",permalink:"/blog/umg_decoupling"},nextItem:{title:"What is component-projection?",permalink:"/blog/component_projection"}},l={authorsImageUrls:[]},p=[{value:"Some examples from the UMG ecosystem:",id:"some-examples-from-the-umg-ecosystem",level:2},{value:"Checklist for systems:",id:"checklist-for-systems",level:2},{value:"Checklist for components:",id:"checklist-for-components",level:2}],m={toc:p},h="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"I am writing this post, because I don't want to make mistakes like this in the future.",(0,r.kt)("br",{parentName:"p"}),"\n","And I think that analyzing past mistakes, and attempting to understand them, are a good way to avoid them."),(0,r.kt)("p",null,"For context, I have been working on UMG for about 2.5 years.",(0,r.kt)("br",{parentName:"p"}),"\n","And throughout this time, over and over, I have made the same mistake of making too many assumptions about the future."),(0,r.kt)("p",null,'When I say "making an assumption", I mean you make a "guess" about how code/data is going to be used.',(0,r.kt)("br",{parentName:"p"}),"\n","APIs can assume a lot, or can assume not much.  "),(0,r.kt)("p",null,"For example: ",(0,r.kt)("inlineCode",{parentName:"p"},"math.distance(x, y)"),(0,r.kt)("br",{parentName:"p"}),"\n","This is a highly ",(0,r.kt)("em",{parentName:"p"},"assumptionless")," API.\nWe do not know (or CARE) where the ",(0,r.kt)("inlineCode",{parentName:"p"},"x,y")," values are from. We just compute the euclidian distance."),(0,r.kt)("p",null,"Another example: ",(0,r.kt)("inlineCode",{parentName:"p"},"uiObject:setBorderColor(color)"),(0,r.kt)("br",{parentName:"p"}),"\n","By contrast, this is an assumption-heavy API.",(0,r.kt)("br",{parentName:"p"}),"\n","We are assuming that ",(0,r.kt)("inlineCode",{parentName:"p"},"uiObject")," has a border.",(0,r.kt)("br",{parentName:"p"}),"\n","We are assuming that the border has a color.",(0,r.kt)("br",{parentName:"p"}),"\n","And we are also assuming that the ",(0,r.kt)("inlineCode",{parentName:"p"},"uiObject")," can be rendered on the screen!"),(0,r.kt)("p",null,'At face value, there is nothing "wrong" with this.',(0,r.kt)("br",{parentName:"p"}),"\n","Assumptions work really well, ",(0,r.kt)("em",{parentName:"p"},"IF")," we guess correctly. If every ",(0,r.kt)("inlineCode",{parentName:"p"},"uiObject")," has a border, then this is great!",(0,r.kt)("br",{parentName:"p"}),"\n","But what happens if we want a transparent image as an element?",(0,r.kt)("br",{parentName:"p"}),"\n","UH OH... This isn't ideal."),(0,r.kt)("p",null,"It'd be much better if ",(0,r.kt)("inlineCode",{parentName:"p"},"uiObject")," didn't have the ",(0,r.kt)("inlineCode",{parentName:"p"},":setBorderColor(color)")," method, and instead, we left border-handling to some other system/object.",(0,r.kt)("br",{parentName:"p"}),"\n","This way, we wouldn't be left with a weird, bloaty method that is only used for some objects."),(0,r.kt)("p",null,"In OOP land, this is very similar to the ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Interface_segregation_principle"},"Interface segregation principle,")," which attempts to isolate behaviour across interfaces as much as possible."),(0,r.kt)("p",null,'In a way, Interface-segregation embodies exactly what I mean by "assumptionless-programming".',(0,r.kt)("br",{parentName:"p"}),"\n","By splitting things into tiny, hyper-specific interfaces; we are assuming ",(0,r.kt)("em",{parentName:"p"},"VERY LITTLE")," about the final structure of our objects.",(0,r.kt)("br",{parentName:"p"}),"\n",'We are basically admitting to the system: "I have no idea what the final objects are going to look like! Thus, I will split the interfaces up as much as possible, so when I implement the concrete classes, the interfaces will fit nicely."'),(0,r.kt)("hr",null),(0,r.kt)("p",null,"In UMG, however, we don't ",(0,r.kt)("em",{parentName:"p"},"often")," do OOP; most UMG code is procedural.",(0,r.kt)("br",{parentName:"p"}),"\n","So, what does procedural assumptionless-code look like?",(0,r.kt)("br",{parentName:"p"}),"\n","I have some examples up my sleeve from UMG:"),(0,r.kt)("h2",{id:"some-examples-from-the-umg-ecosystem"},"Some examples from the UMG ecosystem:"),(0,r.kt)("p",null,"Perhaps the most relevant example as of (27/03/2024) is ui.",(0,r.kt)("br",{parentName:"p"}),"\n","With the UI mod, I (stupidly) made an assumption that all root-UI-elements should be rendered in the main-scene.",(0,r.kt)("br",{parentName:"p"}),"\n","This... was really stupid. Because I've now come across a situation where we need to render UI elements directly in the world, rather than in the upper-level main-scene.",(0,r.kt)("br",{parentName:"p"}),"\n","To fix this, we need to remove the assumption that all root-elements exist in the main-scene; and instead, give the programmer the right to choose where the elements are put.",(0,r.kt)("br",{parentName:"p"}),"\n","(I know; this seems obvious in hindsight!)"),(0,r.kt)("p",null,"Another example is the inventory system.",(0,r.kt)("br",{parentName:"p"}),"\n","A few years ago, I assumed that all inventories would be rendered into the world.",(0,r.kt)("br",{parentName:"p"}),"\n","Think like, a chest. Or an anvil. Or a player inventory.",(0,r.kt)("br",{parentName:"p"}),"\n","All of these can be rendered... no problem, right?",(0,r.kt)("br",{parentName:"p"}),"\n","No!!! This is terrible!",(0,r.kt)("br",{parentName:"p"}),"\n","We have created an assumption about ",(0,r.kt)("em",{parentName:"p"},"how")," the inventory should be rendered. What happens if we want a minecraft-like inventory setup, with a hotbar at the bottom?",(0,r.kt)("br",{parentName:"p"}),"\n","Uh oh... suddenly, we need ",(0,r.kt)("em",{parentName:"p"},"2 different renderers;")," one for the hotbar, and one for the inventory. Not possible under our current setup."),(0,r.kt)("hr",null),(0,r.kt)("br",null),(0,r.kt)("hr",null),(0,r.kt)("p",null,'Ok, so it may be obvious by now that "highly assumptionless code" is a related concept to having ',(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Coupling_(computer_programming)"},"low coupling."),(0,r.kt)("br",{parentName:"p"}),"\n","Whilst I would agree with this, I think coupling is more often used when talking about the internals of a system; or a system as a whole. When writing an internal system, a lot of the time, you don't need to make assumptions about the future; because everything should be contained inside of said system."),(0,r.kt)("p",null,"Assumptions, then, are mostly needed when we are creating an external API, and we are predicting ",(0,r.kt)("em",{parentName:"p"},"how")," the API is to be used.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"../umgtech"},"UMG is truly a different beast"),", for this exact reason. With every base-mod that I write, I am ",(0,r.kt)("em",{parentName:"p"},"FORCED")," to create assumptions about the future of the platform.",(0,r.kt)("br",{parentName:"p"}),"\n","Which sucks, because my previous code has largely sucked at making good assumptions!!",(0,r.kt)("br",{parentName:"p"}),"\n","(I will note, however; that the core UMG-API has been excellent at making no assumptions; so at least I have that haha.)"),(0,r.kt)("p",null,'I also want to point out, a piece of software that I think has a very "lovely" assumptionless structure, is ',(0,r.kt)("a",{parentName:"p",href:"https://love2d.org"},"LOVE")," itself.  With LOVE, the framework doesn't care at all how you structure your game.",(0,r.kt)("br",{parentName:"p"}),"\n","There's no such thing as a gameObject.\nIt doesn't care where you put logic.",(0,r.kt)("br",{parentName:"p"}),"\n","It doesn't care how you load your files, either.",(0,r.kt)("br",{parentName:"p"}),"\n","Isn't that beautiful?",(0,r.kt)("br",{parentName:"p"}),"\n","Another API that is highly assumptionless is ",(0,r.kt)("a",{parentName:"p",href:"https://www.raylib.com/examples.html"},"Raylib.")),(0,r.kt)("br",null),(0,r.kt)("br",null),(0,r.kt)("br",null),(0,r.kt)("h1",{id:"avoiding-bad-assumptions-in-the-future"},"Avoiding bad assumptions in the future:"),(0,r.kt)("p",null,"Obviously, I want to avoid this shit like the plague.",(0,r.kt)("br",{parentName:"p"}),"\n","As such, I have created a lil checklist/procedure for myself to use.",(0,r.kt)("br",{parentName:"p"}),"\n","Here it is:"),(0,r.kt)("h2",{id:"checklist-for-systems"},"Checklist for systems:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"List (abstractly) all actions (",(0,r.kt)("inlineCode",{parentName:"p"},"A"),") that this system is doing/performing."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"For every action ",(0,r.kt)("inlineCode",{parentName:"li"},"A"),", can ",(0,r.kt)("inlineCode",{parentName:"li"},"A")," be split up in any way?",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If so, consider splitting it up."))),(0,r.kt)("li",{parentName:"ul"},"Also, try make ALL ",(0,r.kt)("inlineCode",{parentName:"li"},"A"),"s independent of one another."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"List every dependency / bit of coupling ",(0,r.kt)("inlineCode",{parentName:"p"},"C")," that this system is involved with."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"For each ",(0,r.kt)("inlineCode",{parentName:"li"},"C"),", could we remove this coupling whilst maintaining simplicity?")))),(0,r.kt)("h2",{id:"checklist-for-components"},"Checklist for components:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Attempt to list all the scenarios that this component could be used in.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If there are many scenarios; good. Keep it."),(0,r.kt)("li",{parentName:"ul"},"If the list is lacking, consider killing the component, or making it more generic.")))),(0,r.kt)("br",null),(0,r.kt)("br",null),(0,r.kt)("p",null,"Thanks for reading; ok, lets hope I remember to try use this thing lol."))}u.isMDXComponent=!0}}]);